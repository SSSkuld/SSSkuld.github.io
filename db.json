{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/Chic/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/base.styl","path":"css/base.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/font.styl","path":"css/font.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/layout.styl","path":"css/layout.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/media.styl","path":"css/media.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/normalize.styl","path":"css/normalize.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/variable.styl","path":"css/variable.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/image/avatar.jpeg","path":"image/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","path":"js/mathjax2.7.5.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","path":"fonts/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","path":"fonts/iconfont/demo.css","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","path":"fonts/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","path":"fonts/iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","path":"fonts/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","path":"fonts/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","path":"fonts/iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","path":"fonts/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","path":"fonts/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","path":"fonts/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","path":"fonts/lanting/lanting.TTF","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","path":"fonts/lanting/lanting.eot","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","path":"fonts/lanting/lanting.otf","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","path":"fonts/lanting/lanting.woff","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","path":"fonts/lanting/lanting.woff2","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"e6c5e09c9f19847437c5acb69369894c508d4c51","modified":1600148229227},{"_id":"source/_posts/test.md","hash":"dcdcf49cdd2de1cb75495c7b08ab440b8c4d2dcf","modified":1625504870707},{"_id":"source/_posts/.DS_Store","hash":"efc1b90a49cdc305bb2ee1bcb4c3d054c8073227","modified":1600148928352},{"_id":"themes/Chic/LICENSE.md","hash":"9911bdafa287bd65a822f84cc12012980bd10247","modified":1600085217429},{"_id":"themes/Chic/README-CN.md","hash":"af0765f26b72d49f1b29afe1a9d0c4a492912aaa","modified":1600085217430},{"_id":"themes/Chic/_config.yml","hash":"38fbea5183f6bce9c5a8270e4e88ee5464805f47","modified":1638371398787},{"_id":"themes/Chic/ChangeLogs.md","hash":"82786c20871dd56447d872db9c16bd14b0cf01b8","modified":1600085217429},{"_id":"themes/Chic/README.md","hash":"e0bd27664e1d0b4ed1c8101d2bf69886c66c31d9","modified":1600085217430},{"_id":"themes/Chic/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1600085217430},{"_id":"themes/Chic/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1600085217430},{"_id":"themes/Chic/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1600085217430},{"_id":"themes/Chic/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1600085217430},{"_id":"themes/Chic/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1600085217430},{"_id":"themes/Chic/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1600085217431},{"_id":"themes/Chic/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1600085217431},{"_id":"themes/Chic/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1600085217431},{"_id":"themes/Chic/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1600085217431},{"_id":"themes/Chic/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1600085217431},{"_id":"themes/Chic/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1600085217431},{"_id":"themes/Chic/package.json","hash":"8b4072879307eed0e74ae35390825c5e03b9229c","modified":1600085217434},{"_id":"themes/Chic/.DS_Store","hash":"3f3a1c330022f977727012609debd856797b90ed","modified":1600146839519},{"_id":"themes/Chic/source/favicon.ico","hash":"45416a85d30bfe671e0fb5efb273118c4ee0496f","modified":1623750810319},{"_id":"themes/Chic/scripts/imageTag.js","hash":"4b69804c1e4bf638eda7022499c440ce24e28587","modified":1600085217435},{"_id":"themes/Chic/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1600085217431},{"_id":"themes/Chic/layout/.DS_Store","hash":"cfa5c6d2ec5f996d5cd0e6dae1d358c3f0a18e02","modified":1600139838968},{"_id":"themes/Chic/layout/archive.ejs","hash":"48cdf67b628eb6a1c24d484ed252f5b0e3f06ddf","modified":1600085217434},{"_id":"themes/Chic/layout/category.ejs","hash":"cae7483c92ff639f74f8efe67959f37c97350800","modified":1600085217434},{"_id":"themes/Chic/source/.DS_Store","hash":"faf9e0782b5ad48eee40804a3a2be2e3b3bd68f8","modified":1600139970970},{"_id":"themes/Chic/layout/index.ejs","hash":"b3344720176ad12dc88745cc5b31d497356ca4fa","modified":1600085217434},{"_id":"themes/Chic/layout/layout.ejs","hash":"f874320edabdefc204f9e17d119a16d16f26c363","modified":1600085217434},{"_id":"themes/Chic/layout/page.ejs","hash":"3179c527694a789760742e1923c7ac5f94b4997c","modified":1600085217434},{"_id":"themes/Chic/layout/post.ejs","hash":"a23f83d6c559ce88588472267468a54488d50e8e","modified":1600085217434},{"_id":"themes/Chic/layout/tag.ejs","hash":"d85ca78392be138b1589499cba95186b20c3a902","modified":1600085217434},{"_id":"themes/Chic/source/css/base.styl","hash":"7ea2db2c139a719bb7d3f3c5e182dd0e0d59e098","modified":1600085217451},{"_id":"themes/Chic/source/css/custom.styl","hash":"bf8dee1a094b104d87a53b43f6daa7ba43b67574","modified":1600085217451},{"_id":"themes/Chic/source/css/font.styl","hash":"8c1da30e223c0a3d7ef452abc9f0e4cc71dbc140","modified":1600085217451},{"_id":"themes/Chic/source/css/layout.styl","hash":"9942d05bb2c55cf035d4bf9af325e1e81766a510","modified":1600085217451},{"_id":"themes/Chic/source/css/media.styl","hash":"f96c0dbb9653667906a6dc271f637543ac5c7212","modified":1600085217451},{"_id":"themes/Chic/source/css/.DS_Store","hash":"a6b25bfb26cf633e8c5d0aca4aff7421e02a5e9a","modified":1600139861969},{"_id":"themes/Chic/source/fonts/.DS_Store","hash":"6f42bdb50e21f816210b084926b8418a6ce88af7","modified":1600092274634},{"_id":"themes/Chic/source/css/normalize.styl","hash":"b3337320133b7a336db7033aa6bbe94b054c0b21","modified":1600085217452},{"_id":"themes/Chic/source/css/style.styl","hash":"a13f2c38070a89b06a2ede599f5ce5fd160e11c9","modified":1600085217452},{"_id":"themes/Chic/source/css/variable.styl","hash":"906faa95457eba70118a0705e13b8f43409e502f","modified":1600085217452},{"_id":"themes/Chic/source/js/script.js","hash":"93694e4e16893f83611daa5ba3723b14ecc80abb","modified":1600085217539},{"_id":"themes/Chic/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1600085217539},{"_id":"themes/Chic/layout/_page/archive.ejs","hash":"464549286c92ea0d6cb057c6936e0f1a5d1c1dd2","modified":1600085217431},{"_id":"themes/Chic/layout/_page/category.ejs","hash":"e8464e11d08a711fe815ea1cd101aa41d7310ebf","modified":1600085217432},{"_id":"themes/Chic/source/image/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1600089514082},{"_id":"themes/Chic/layout/_page/post.ejs","hash":"6eb9cd3ee904e99ff78509298ae31a29fdbf49cf","modified":1600085217432},{"_id":"themes/Chic/layout/_page/page.ejs","hash":"1d875d59cf4d6b681cc8cf755f19b5355e5d1144","modified":1600085217432},{"_id":"themes/Chic/layout/_page/profile.ejs","hash":"c6d3cf2ef90e5d0fd580e7cff1db47c28fb36037","modified":1600085217432},{"_id":"themes/Chic/layout/_page/tag.ejs","hash":"0c20ff00532103f9a59639ca9956fc0bce4aabc2","modified":1600085217432},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1600085217538},{"_id":"themes/Chic/layout/_plugins/mathjax.ejs","hash":"53f088fe44d51c4d9fb61aeac4c23b3cfcc19762","modified":1600085217433},{"_id":"themes/Chic/layout/_partial/head.ejs","hash":"8c8a2d95e0858cf0be9bf60d0ddf26876e1d9d35","modified":1600085217432},{"_id":"themes/Chic/layout/_partial/footer.ejs","hash":"e1c332fab0d6cd713e36d46ccc14d0991067ba40","modified":1600085217432},{"_id":"themes/Chic/layout/_partial/header.ejs","hash":"8f1e5272a4de96a3ed94de1db988b05b34515463","modified":1600085217433},{"_id":"themes/Chic/layout/_partial/paginator.ejs","hash":"ab59d5db77f2aa64dfe03656e72fd49702c62e23","modified":1600085217433},{"_id":"themes/Chic/layout/_partial/toc.ejs","hash":"10bb9c303c948f5615149981cd85cbbd3e7c781c","modified":1600085217433},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1600085217453},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1600085217453},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1600085217453},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1600085217453},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1600085217455},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","hash":"eae94b803d34035008842855d0bead92d2035281","modified":1600085217454},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1600085217454},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1600085217455},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1600085217454},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1600085217455},{"_id":"themes/Chic/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1600085217435},{"_id":"themes/Chic/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1600085217435},{"_id":"themes/Chic/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1600085217435},{"_id":"themes/Chic/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1600085217436},{"_id":"themes/Chic/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1600085217435},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1600085217436},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1600085217436},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1600085217436},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1600085217436},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1600085217436},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1600085217436},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1600085217437},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1600085217437},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1600085217437},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1600085217437},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1600085217437},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1600085217437},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1600085217437},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1600085217438},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1600085217438},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1600085217438},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1600085217438},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1600085217438},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1600085217438},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1600085217438},{"_id":"themes/Chic/source/css/_highlight/brown-paper.styl","hash":"329b85ae9130a5587a6fb1c6f80396f9cca5ddc1","modified":1600085217438},{"_id":"themes/Chic/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1600085217438},{"_id":"themes/Chic/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1600085217439},{"_id":"themes/Chic/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1600085217439},{"_id":"themes/Chic/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1600085217439},{"_id":"themes/Chic/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1600085217439},{"_id":"themes/Chic/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1600085217439},{"_id":"themes/Chic/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1600085217439},{"_id":"themes/Chic/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1600085217440},{"_id":"themes/Chic/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1600085217439},{"_id":"themes/Chic/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1600085217440},{"_id":"themes/Chic/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1600085217440},{"_id":"themes/Chic/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1600085217440},{"_id":"themes/Chic/source/css/_highlight/highlightjs.styl","hash":"65b5981dc3c57cedd1cb668c0e377230987e08d1","modified":1600085217440},{"_id":"themes/Chic/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1600085217440},{"_id":"themes/Chic/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1600085217441},{"_id":"themes/Chic/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1600085217441},{"_id":"themes/Chic/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1600085217441},{"_id":"themes/Chic/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1600085217441},{"_id":"themes/Chic/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1600085217442},{"_id":"themes/Chic/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1600085217441},{"_id":"themes/Chic/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1600085217442},{"_id":"themes/Chic/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1600085217442},{"_id":"themes/Chic/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1600085217442},{"_id":"themes/Chic/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1600085217442},{"_id":"themes/Chic/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1600085217443},{"_id":"themes/Chic/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1600085217443},{"_id":"themes/Chic/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1600085217443},{"_id":"themes/Chic/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1600085217443},{"_id":"themes/Chic/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1600085217443},{"_id":"themes/Chic/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1600085217444},{"_id":"themes/Chic/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1600085217444},{"_id":"themes/Chic/source/css/_highlight/pojoaque.styl","hash":"2601b4285803a7cea5ccded8d624ca95f80e3d88","modified":1600085217444},{"_id":"themes/Chic/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1600085217444},{"_id":"themes/Chic/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1600085217444},{"_id":"themes/Chic/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1600085217444},{"_id":"themes/Chic/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1600085217445},{"_id":"themes/Chic/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1600085217445},{"_id":"themes/Chic/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1600085217445},{"_id":"themes/Chic/source/css/_highlight/school-book.styl","hash":"beabbbcc7930f8de19159381a01c0ba41dc2291f","modified":1600085217445},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1600085217446},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1600085217446},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1600085217446},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1600085217446},{"_id":"themes/Chic/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1600085217446},{"_id":"themes/Chic/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1600085217446},{"_id":"themes/Chic/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1600085217447},{"_id":"themes/Chic/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1600085217447},{"_id":"themes/Chic/source/css/_lib/looper.css","hash":"863144dc9af7c1e181670515bc85eaf768f4e287","modified":1600085217447},{"_id":"themes/Chic/source/css/_lib/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1600085217447},{"_id":"themes/Chic/source/css/_page/archive.styl","hash":"71ea842f068b29b4418dd09450db09d27dcf0947","modified":1600085217449},{"_id":"themes/Chic/source/css/_page/category.styl","hash":"cead361269616b7a6ddec3090d9fa34c3c6ac722","modified":1600085217450},{"_id":"themes/Chic/source/css/_page/page.styl","hash":"34e33b52d2e046aa2f5494e81ff4ac2d5ca78058","modified":1600085217450},{"_id":"themes/Chic/source/css/_page/profile.styl","hash":"5ef6d5a06132f26b7aa01b2fbf4bbfb8ee862b7b","modified":1600085217450},{"_id":"themes/Chic/source/css/_page/tag.styl","hash":"55b220cc58011876fb3a470cd1fde8ed87c93079","modified":1600085217450},{"_id":"themes/Chic/source/css/_partial/footer.styl","hash":"4f58e607eaa59cda3b5a9fdb3404ffb75c4d1a03","modified":1600085217450},{"_id":"themes/Chic/source/css/_partial/header.styl","hash":"be70b4ab3bcc977f1055664899742804c716929d","modified":1600085217451},{"_id":"themes/Chic/source/css/_partial/paginator.styl","hash":"b4f4a5180c4cbc70d186792b8a1fd0f5855bd86a","modified":1600085217451},{"_id":"themes/Chic/source/css/_page/.DS_Store","hash":"c89d2ef3b87043adc4b04d1d2e8a6c33895f6e5b","modified":1600139965952},{"_id":"themes/Chic/source/css/_page/_post/post_code.styl","hash":"06c3a3524ffd4b27e03e79489001997ea5d727d3","modified":1600085217448},{"_id":"themes/Chic/source/css/_page/_post/post_content.styl","hash":"5e3d63077549d8e2e5ff8c452e809760f5a99c17","modified":1600085217448},{"_id":"themes/Chic/source/css/_page/_post/post_header.styl","hash":"d37b032bc5edca92c84bf62070a28fa40939df55","modified":1600085217449},{"_id":"themes/Chic/source/css/_page/_post/post_copyright.styl","hash":"64fd9f07ed45f035057d46740af0db70218714aa","modified":1600085217448},{"_id":"themes/Chic/source/css/_page/_post/post_nav.styl","hash":"03accaba13c995cbe65a05a88549ff74e992eb3f","modified":1600085217449},{"_id":"themes/Chic/source/css/_page/_post/post_tags.styl","hash":"2ff93677aa4d81da83c659b4dd4e3cb482d9ce7d","modified":1600085217449},{"_id":"themes/Chic/source/css/_page/_post/post_toc.styl","hash":"15e1ec7af93f41184f986aba21991a79923b0a0e","modified":1600085217449},{"_id":"themes/Chic/source/image/avatar.jpeg","hash":"fa746eb12b2e2ccda1824e2429d065d2305fc6a8","modified":1600089283000},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1600085217537},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1600085217534},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1600085217497},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1600085217475},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1600085217530},{"_id":"public/archives/index.html","hash":"ec19343255a5aedf60a1d913c0bb567815f62250","modified":1676873301245},{"_id":"public/archives/2020/index.html","hash":"c3918421bad658d47aca50fe8856c1e5798a3b7b","modified":1623827145715},{"_id":"public/2020/09/15/test/index.html","hash":"f14fb0046d4ffe8d25b4493ec1cdbca51618efd2","modified":1637254218922},{"_id":"public/archives/2020/09/index.html","hash":"2691bee54f581f90da4a3f25fb38f90c7c6b1c1d","modified":1623827145715},{"_id":"public/index.html","hash":"8aa8d6fd258bdb9975bfb64d11f78055b424f70a","modified":1638371403049},{"_id":"public/tags/none/index.html","hash":"434e89f34ba172a755ce00277c69caa882b083e7","modified":1600148952112},{"_id":"public/favicon.ico","hash":"45416a85d30bfe671e0fb5efb273118c4ee0496f","modified":1638794331436},{"_id":"public/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1600148952112},{"_id":"public/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1637563267944},{"_id":"public/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1600148952112},{"_id":"public/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1600148952112},{"_id":"public/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1600148952112},{"_id":"public/image/avatar.jpeg","hash":"fa746eb12b2e2ccda1824e2429d065d2305fc6a8","modified":1600148952112},{"_id":"public/css/base.css","hash":"ea2d491ce6242c6b7087a2652a1135694c292137","modified":1600148952112},{"_id":"public/css/font.css","hash":"87059edd1f2bfc4296f5599e73208893f2b06458","modified":1600148952112},{"_id":"public/css/custom.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1600148952112},{"_id":"public/css/media.css","hash":"5023ee404900a47d61ca0591b2d4e9eace0fe88e","modified":1600148952112},{"_id":"public/css/normalize.css","hash":"2d4b663b6a4c68295b6ba240fa2dd9fb3863093c","modified":1600148952112},{"_id":"public/css/layout.css","hash":"c81e2e01ff5e95a3e613064b8490045ff936c305","modified":1600148952112},{"_id":"public/css/variable.css","hash":"cb4180b3bbad471e30cf52ebb40e998d58a30d7d","modified":1600148952112},{"_id":"public/js/script.js","hash":"93694e4e16893f83611daa5ba3723b14ecc80abb","modified":1600148952112},{"_id":"public/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1600148952112},{"_id":"public/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1600148952112},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1600148952112},{"_id":"public/fonts/iconfont/iconfont.json","hash":"3123aa840109e385d58a75d34e88a2d621e1ada8","modified":1600148952112},{"_id":"public/css/style.css","hash":"534ca54902458408412998bd6254ecfb3c50ad35","modified":1600148952112},{"_id":"public/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1600148952112},{"_id":"public/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1600148952112},{"_id":"public/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1600148952112},{"_id":"public/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1600148952112},{"_id":"public/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1600148952112},{"_id":"public/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1600148952112},{"_id":"public/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1600148952112},{"_id":"public/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1600148952112},{"_id":"source/about.md","hash":"915a498c94404b54262bfdb1f2ab39ea10a9333b","modified":1638794431922},{"_id":"public/about.html","hash":"1adcd846719dc19b33ed31fd261d6595df3b1268","modified":1638794501801},{"_id":"source/_posts/Windows-Clion环境搭建.md","hash":"cf7e17f1df7992b3c8080470150ac1a6771e95a0","modified":1638946477597},{"_id":"public/2021/11/19/Windows-Clion环境搭建/index.html","hash":"8a949303dc0a5097097ad54afb5483d6edf16474","modified":1638946493388},{"_id":"public/archives/2021/index.html","hash":"3c80e22ffab7a9a8717d05239a1ea06b470e4e12","modified":1639556990207},{"_id":"public/archives/2021/11/index.html","hash":"efe6afe0e8aa44d6e49a57f0c0b0e1cd0ac233f3","modified":1638371403049},{"_id":"public/tags/Linux/index.html","hash":"7b647f3fbf08173f0e09fa8a518d8e321454b8ca","modified":1639556990207},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）.md","hash":"779517403f797b94eda8b245dc47c9ba1f9a8b27","modified":1638794470205},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/isa_t.png","hash":"c6eef0fe26188074ed8ba4a50b10257e40e071d6","modified":1638281620996},{"_id":"public/2021/11/30/基于objc4的Runtime原理解读（一）/index.html","hash":"a87891530d977641dbbe4ed082c2215a640312e9","modified":1638794501801},{"_id":"public/2021/11/30/基于objc4的Runtime原理解读（一）/isa_t.png","hash":"c6eef0fe26188074ed8ba4a50b10257e40e071d6","modified":1638283805679},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/ro.png","hash":"2946cf24f09aa4f85475562be87ac879878763c1","modified":1638369255429},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/rw.png","hash":"ffdd86098e404d9b5552df54a44b64434ea756be","modified":1638369268626},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/class.png","hash":"ab0ce38e181f98a5cae8c3d954a646105f4176a2","modified":1638283877982},{"_id":"public/2021/11/30/基于objc4的Runtime原理解读（一）/ro.png","hash":"2946cf24f09aa4f85475562be87ac879878763c1","modified":1638369318448},{"_id":"public/2021/11/30/基于objc4的Runtime原理解读（一）/rw.png","hash":"ffdd86098e404d9b5552df54a44b64434ea756be","modified":1638369318448},{"_id":"public/2021/11/30/基于objc4的Runtime原理解读（一）/class.png","hash":"ab0ce38e181f98a5cae8c3d954a646105f4176a2","modified":1638369318448},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/summary.png","hash":"4b8778b6fd6e74610893142ef138585ab1959fdd","modified":1638370359796},{"_id":"public/tags/iOS/index.html","hash":"2ca130852c39529272372b9c024c17c2d1c14c89","modified":1676873301245},{"_id":"public/2021/11/30/基于objc4的Runtime原理解读（一）/summary.png","hash":"4b8778b6fd6e74610893142ef138585ab1959fdd","modified":1638370439217},{"_id":"source/tags/index.md","hash":"266c68c0b13742411ec5d5f3f566897be9b23a8e","modified":1638370837104},{"_id":"public/tags/index.html","hash":"c57e9afb18cd823d2a83086baf159efa7a38c3f2","modified":1638371087807},{"_id":"source/tag/index.md","hash":"bc6a8c4a2e7a1dc15f7bb80b6c3c94f303fba335","modified":1638371388623},{"_id":"public/tag/index.html","hash":"d33829ebd0cee3b2362341278b947a294057f9aa","modified":1676873301245},{"_id":"source/category/index.md","hash":"9b6c3c93e9ac4cff13325adaafc0cb561e7ca0a6","modified":1638371463998},{"_id":"public/category/index.html","hash":"a441b5852ccdd29c8dcd9d9fa54202aec96b8c93","modified":1676873301245},{"_id":"source/CNAME","hash":"b57edcff08fa4e717dd78895ff143d58f1e62e40","modified":1676865342351},{"_id":"public/CNAME","hash":"b57edcff08fa4e717dd78895ff143d58f1e62e40","modified":1676865806523},{"_id":"source/_posts/基于objc4的Runtime原理解读（二）.md","hash":"df5568f5f86609cc57272a2334430f0f1fff7674","modified":1638889581918},{"_id":"public/2021/12/06/基于objc4的Runtime原理解读（二）/index.html","hash":"34041350d9f5b54eca231018c660c0795317f61c","modified":1639488204690},{"_id":"public/archives/2021/12/index.html","hash":"d55a9184039c1e361cde643c3713134d10e4738f","modified":1639556990207},{"_id":"public/categories/Linux/index.html","hash":"b3648eb1d4fd79f0d84d7b0155de075db70524ca","modified":1639488270709},{"_id":"public/categories/iOS/index.html","hash":"9a17f4cc355bd1f7ccb77dc5a2d0b202dfdf6779","modified":1676873301245},{"_id":"public/tags/CLion/index.html","hash":"dbb86cf62120028ea7fc4d2e060f7f1361d02da4","modified":1638794095643},{"_id":"public/tags/WSL/index.html","hash":"f077da11105e4dec148a1cac49325b26950b5dc7","modified":1638794095643},{"_id":"public/tags/objective-c/index.html","hash":"e49d72f1b2b6b2a3e8a8025f7cde020575df5971","modified":1638889587446},{"_id":"public/tags/runtime/index.html","hash":"1c620ccc7d39c10e4f25f41790fcd84c1fcb7326","modified":1638889587446},{"_id":"source/_posts/基于objc4的Runtime原理解读（二）/class.png","hash":"5ff134d19352d15c760f5635d957faf5b359b746","modified":1638801309039},{"_id":"public/2021/12/06/基于objc4的Runtime原理解读（二）/class.png","hash":"5ff134d19352d15c760f5635d957faf5b359b746","modified":1638889587446},{"_id":"source/_posts/Linux高效文件处理命令——grep.md","hash":"fdf7ea4c1c2b7d81101fe18abf4728f596a6f668","modified":1639556985135},{"_id":"public/2021/12/14/Linux高效文件处理命令——grep/index.html","hash":"fdf0c73012ae3a5267f9fc6c7fa3a1580eaa49df","modified":1676865806523},{"_id":"source/_drafts/Linux高效文件处理命令——grep.md","hash":"ec6e36aec3f30efb432e7b4672f3099586b86da2","modified":1639488264275},{"_id":"public/tags/终端/index.html","hash":"3c46424e6d8501602d1c9aa55292958811325a70","modified":1639488270709},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1639556954527},{"_id":"source/_drafts/聊聊动态链接.md","hash":"8603aef3a6322f636753b667954a230097a68957","modified":1676873218929},{"_id":"source/_drafts/聊聊动态链接/dyld-2.png","hash":"10af2200286fed40a2acf6111ecbad93f715c655","modified":1676865666651},{"_id":"source/_drafts/聊聊动态链接/static_linker_1.png","hash":"35e10c9e715f006b6886e173fa9304fff26dbb45","modified":1676865666751},{"_id":"source/_drafts/聊聊动态链接/static_linker_2.png","hash":"c663142c86b8684057dff78eb85d3a2605e899f0","modified":1676865666764},{"_id":"source/_drafts/聊聊动态链接/dyld-6.png","hash":"68b3647a9d8c94740cdaa7ece0f728fb11f3a1f3","modified":1676865666678},{"_id":"source/_drafts/聊聊动态链接/mach-o.png","hash":"a48e4f58b5f99dd6b8754f669a6064f863aab8da","modified":1676865666743},{"_id":"source/_drafts/聊聊动态链接/static_linker_3.png","hash":"00e230ecb84fbebe902637baf0825bf946378874","modified":1676865666769},{"_id":"source/_drafts/聊聊动态链接/dyld-12.png","hash":"b75ce8666dc35aee90d1d521acd3c1b6837d05d3","modified":1676865666726},{"_id":"source/_drafts/聊聊动态链接/dyld-8.png","hash":"7f46bed562ea235feceee9c598102119655ef93e","modified":1676865666693},{"_id":"source/_drafts/聊聊动态链接/dyld-5.png","hash":"dc947c3245ad257643ea62f5c9867a3bba295717","modified":1676865666674},{"_id":"source/_drafts/聊聊动态链接/dyld-4.png","hash":"6d498da42d3caa24f776e5e54ce87964fe7d7ec2","modified":1676865666667},{"_id":"source/_drafts/聊聊动态链接/dyld-7.png","hash":"5a27dadbe1c1f15a07e671056d2eeb1c571d1fac","modified":1676865666686},{"_id":"source/_drafts/聊聊动态链接/dyld-1.png","hash":"284cfc0cb850521a8bf0123180ecf0466d5705d0","modified":1676865666642},{"_id":"source/_drafts/聊聊动态链接/dyld-13.png","hash":"4f3f77c024995fb65a3b6ddc19d31de935ac2401","modified":1676865666734},{"_id":"source/_drafts/聊聊动态链接/dyld-9.png","hash":"3aa1402259572e5008e1cf9161cc907c2365cd8a","modified":1676865666701},{"_id":"source/_drafts/聊聊动态链接/dyld-3.png","hash":"b6ac5b8d8488940b976c9473fe122a0f336460de","modified":1676865666659},{"_id":"source/_drafts/聊聊动态链接/dyld-11.png","hash":"6ce33a77cb9a32eab3811e205395925203431033","modified":1676865666718},{"_id":"source/_drafts/聊聊动态链接/dyld-10.png","hash":"d792bffc2e4c5029f63597208f363a3fc057e455","modified":1676865666711},{"_id":"public/archives/2023/index.html","hash":"169fa591578334d26de847077259850684f4d24e","modified":1676873301245},{"_id":"public/archives/2023/02/index.html","hash":"a3d4e6d2841c0e31c589b13ebf01c7501bd9ae40","modified":1676873301245},{"_id":"public/2023/02/16/聊聊动态链接/index.html","hash":"d3890106d623ec9aa93762e47653199f4d3fde38","modified":1676876739368},{"_id":"public/tags/linker/index.html","hash":"507160560bf11e3cc523f9141098b0acccf65b02","modified":1676873301245},{"_id":"source/_posts/聊聊动态链接.md","hash":"13c3deb0c8e8b6852bfa6d50415380458fc20a7b","modified":1676876733401},{"_id":"source/_posts/聊聊动态链接/dyld-2.png","hash":"10af2200286fed40a2acf6111ecbad93f715c655","modified":1676873202182},{"_id":"source/_posts/聊聊动态链接/static_linker_1.png","hash":"35e10c9e715f006b6886e173fa9304fff26dbb45","modified":1676873202189},{"_id":"source/_posts/聊聊动态链接/static_linker_2.png","hash":"c663142c86b8684057dff78eb85d3a2605e899f0","modified":1676873202189},{"_id":"source/_posts/聊聊动态链接/dyld-6.png","hash":"68b3647a9d8c94740cdaa7ece0f728fb11f3a1f3","modified":1676873202188},{"_id":"source/_posts/聊聊动态链接/mach-o.png","hash":"a48e4f58b5f99dd6b8754f669a6064f863aab8da","modified":1676873202189},{"_id":"source/_posts/聊聊动态链接/static_linker_3.png","hash":"00e230ecb84fbebe902637baf0825bf946378874","modified":1676873202190},{"_id":"source/_posts/聊聊动态链接/dyld-12.png","hash":"b75ce8666dc35aee90d1d521acd3c1b6837d05d3","modified":1676873202180},{"_id":"source/_posts/聊聊动态链接/dyld-8.png","hash":"7f46bed562ea235feceee9c598102119655ef93e","modified":1676873202189},{"_id":"source/_posts/聊聊动态链接/dyld-4.png","hash":"6d498da42d3caa24f776e5e54ce87964fe7d7ec2","modified":1676873202185},{"_id":"source/_posts/聊聊动态链接/dyld-5.png","hash":"dc947c3245ad257643ea62f5c9867a3bba295717","modified":1676873202187},{"_id":"source/_posts/聊聊动态链接/dyld-7.png","hash":"5a27dadbe1c1f15a07e671056d2eeb1c571d1fac","modified":1676873202189},{"_id":"source/_posts/聊聊动态链接/dyld-1.png","hash":"284cfc0cb850521a8bf0123180ecf0466d5705d0","modified":1676873202181},{"_id":"source/_posts/聊聊动态链接/dyld-13.png","hash":"4f3f77c024995fb65a3b6ddc19d31de935ac2401","modified":1676873202183},{"_id":"source/_posts/聊聊动态链接/dyld-9.png","hash":"3aa1402259572e5008e1cf9161cc907c2365cd8a","modified":1676873202190},{"_id":"source/_posts/聊聊动态链接/dyld-3.png","hash":"b6ac5b8d8488940b976c9473fe122a0f336460de","modified":1676873202186},{"_id":"source/_posts/聊聊动态链接/dyld-11.png","hash":"6ce33a77cb9a32eab3811e205395925203431033","modified":1676873202182},{"_id":"source/_posts/聊聊动态链接/dyld-10.png","hash":"d792bffc2e4c5029f63597208f363a3fc057e455","modified":1676873202185},{"_id":"public/2023/02/16/聊聊动态链接/dyld-2.png","hash":"10af2200286fed40a2acf6111ecbad93f715c655","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/static_linker_1.png","hash":"35e10c9e715f006b6886e173fa9304fff26dbb45","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/static_linker_2.png","hash":"c663142c86b8684057dff78eb85d3a2605e899f0","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-6.png","hash":"68b3647a9d8c94740cdaa7ece0f728fb11f3a1f3","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/mach-o.png","hash":"a48e4f58b5f99dd6b8754f669a6064f863aab8da","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/static_linker_3.png","hash":"00e230ecb84fbebe902637baf0825bf946378874","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-12.png","hash":"b75ce8666dc35aee90d1d521acd3c1b6837d05d3","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-8.png","hash":"7f46bed562ea235feceee9c598102119655ef93e","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-4.png","hash":"6d498da42d3caa24f776e5e54ce87964fe7d7ec2","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-5.png","hash":"dc947c3245ad257643ea62f5c9867a3bba295717","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-7.png","hash":"5a27dadbe1c1f15a07e671056d2eeb1c571d1fac","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-1.png","hash":"284cfc0cb850521a8bf0123180ecf0466d5705d0","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-13.png","hash":"4f3f77c024995fb65a3b6ddc19d31de935ac2401","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-9.png","hash":"3aa1402259572e5008e1cf9161cc907c2365cd8a","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-3.png","hash":"b6ac5b8d8488940b976c9473fe122a0f336460de","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-11.png","hash":"6ce33a77cb9a32eab3811e205395925203431033","modified":1676873225694},{"_id":"public/2023/02/16/聊聊动态链接/dyld-10.png","hash":"d792bffc2e4c5029f63597208f363a3fc057e455","modified":1676873225694},{"_id":"source/_posts/聊聊动态链接/dyld-14.png","hash":"b82e48a3e00957aae1317b12d2a613e4117c5370","modified":1676876453906},{"_id":"public/2023/02/16/聊聊动态链接/dyld-14.png","hash":"b82e48a3e00957aae1317b12d2a613e4117c5370","modified":1676876595706}],"Category":[{"name":"Linux","_id":"ckwunoxbd00000bmjdueq4nij"},{"name":"iOS","_id":"ckwunoxbg00030bmjb84hbuje"}],"Data":[],"Page":[{"title":"About me","date":"2021-06-17T12:23:21.000Z","_content":"\n邮箱：skuldchoi@qq.com\n\n微信：skuld9102\n\n多思考，多总结。","source":"about.md","raw":"---\ntitle: About me\ndate: 2021-06-17 20:23:21\n---\n\n邮箱：skuldchoi@qq.com\n\n微信：skuld9102\n\n多思考，多总结。","updated":"2021-12-06T12:40:31.922Z","path":"about.html","_id":"ckq0w7bp40000q0mj1frkcg3p","comments":1,"layout":"page","content":"<p>邮箱：<a href=\"mailto:&#x73;&#x6b;&#x75;&#108;&#x64;&#x63;&#x68;&#111;&#105;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;\">&#x73;&#x6b;&#x75;&#108;&#x64;&#x63;&#x68;&#111;&#105;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a></p>\n<p>微信：skuld9102</p>\n<p>多思考，多总结。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>邮箱：<a href=\"mailto:&#x73;&#x6b;&#x75;&#108;&#x64;&#x63;&#x68;&#111;&#105;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;\">&#x73;&#x6b;&#x75;&#108;&#x64;&#x63;&#x68;&#111;&#105;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a></p>\n<p>微信：skuld9102</p>\n<p>多思考，多总结。</p>\n"},{"title":"tag","date":"2021-12-01T15:09:33.000Z","layout":"tag","_content":"","source":"tag/index.md","raw":"---\ntitle: tag\ndate: 2021-12-01 23:09:33\nlayout: tag\n---\n","updated":"2021-12-01T15:09:48.623Z","path":"tag/index.html","comments":1,"_id":"ckwno15ir0000immjdxcz94fl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"category","date":"2021-12-01T15:10:51.000Z","layout":"category","_content":"","source":"category/index.md","raw":"---\ntitle: category\ndate: 2021-12-01 23:10:51\nlayout: category\n---\n","updated":"2021-12-01T15:11:03.998Z","path":"category/index.html","comments":1,"_id":"ckwno2r710000m0mja3add430","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Windows+Clion环境搭建","date":"2021-11-18T16:23:57.000Z","_content":"## 背景\n最近开始学习网络编程，自己的Windows主机上一直没有搭建相关的开发环境，下载Clion后发现缺少一系列的编译工具链。网上查阅资料后，发现使用Windows的WSL工具，不用安装虚拟机就可以方便的拥有一个Linux环境，并且CLion也可以在这个环境下进行编译。\n\n一通尝试下来发现确实方便，Windows+WSL+CLion的工具环境轻量又好用，应该是以后在家的主要工作环境了。\n## 步骤\n### 1.开启WSL\n按 Win+X, 找到 Windows PowerShell (管理员)，并复制执行命令。\n\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\n\n这个命令会激活WSL功能，之后需要重启电脑。\n重启电脑之后，win+R，输入 appwiz.cpl，左上角找到“启动或关闭 Windows 功能”，会看到“适用于Linux的Windows子系统”选项处于选中状态。\n\n其实之前这个命令就相当于手动打开这个选中项。\n### 2.安装WSL发行版本\n在微软应用商城里搜索Ubuntu，选择一个合适的版本安装即可，这里推荐安装Ubuntu 20.04 LTS。\n\n依次获取、安装，国内网络环境下微软应用商店可能存在些延迟，耐心等一下或者翻墙下载均可。\n\n安装完后，打开Ubuntu即可，按照提示依次设置好用户名和密码即可。\n\n接下来可以进行一些Linux常规的环境配置。\n\n首先进行apt换源，我使用的是阿里云镜像。\n\n<b>\n【⚠】首先需要备份一下sources.list文件，很重要不要跳过。\n</b>\n\n```\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n```\n\n之后执行vim /etc/apt/sources.list，替换文件内容即可。\n\n```\ndeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n```\n\n之后更新软件\n```\nsudo apt-get update\nsudo apt-get upgrade\n```\n\n注意，此时如果对sources.list文件操作不当，可能会触发如下报错：\n```\nMalformed line 1 in source list /etc/apt/sources.list (type)\nThe list of sources could not be read.\n```\n\n此时前往/etc/apt目录下，执行 sudo rm sources.list 删除文件\n之后sudo touch sources.list\n打开文件，将替换内容复制进去并保存即可。\n### 3.CLion编译环境配置\n打开CLion项目，会提示编译工具链缺失。\n\n选择环境为WSL，CLion会自动检查对应工具的缺失情况，根据报错，缺少哪个，在Ubuntu的终端中对应下载即可。\n\n至此整个流程结束，整个搭建流程还是很快速的。\n\n\n\n\n","source":"_posts/Windows-Clion环境搭建.md","raw":"---\ntitle: Windows+Clion环境搭建\ndate: 2021-11-19 00:23:57\ntags: \n- Linux\n- CLion\n- WSL\ncategories: Linux\n---\n## 背景\n最近开始学习网络编程，自己的Windows主机上一直没有搭建相关的开发环境，下载Clion后发现缺少一系列的编译工具链。网上查阅资料后，发现使用Windows的WSL工具，不用安装虚拟机就可以方便的拥有一个Linux环境，并且CLion也可以在这个环境下进行编译。\n\n一通尝试下来发现确实方便，Windows+WSL+CLion的工具环境轻量又好用，应该是以后在家的主要工作环境了。\n## 步骤\n### 1.开启WSL\n按 Win+X, 找到 Windows PowerShell (管理员)，并复制执行命令。\n\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\n\n这个命令会激活WSL功能，之后需要重启电脑。\n重启电脑之后，win+R，输入 appwiz.cpl，左上角找到“启动或关闭 Windows 功能”，会看到“适用于Linux的Windows子系统”选项处于选中状态。\n\n其实之前这个命令就相当于手动打开这个选中项。\n### 2.安装WSL发行版本\n在微软应用商城里搜索Ubuntu，选择一个合适的版本安装即可，这里推荐安装Ubuntu 20.04 LTS。\n\n依次获取、安装，国内网络环境下微软应用商店可能存在些延迟，耐心等一下或者翻墙下载均可。\n\n安装完后，打开Ubuntu即可，按照提示依次设置好用户名和密码即可。\n\n接下来可以进行一些Linux常规的环境配置。\n\n首先进行apt换源，我使用的是阿里云镜像。\n\n<b>\n【⚠】首先需要备份一下sources.list文件，很重要不要跳过。\n</b>\n\n```\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n```\n\n之后执行vim /etc/apt/sources.list，替换文件内容即可。\n\n```\ndeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n```\n\n之后更新软件\n```\nsudo apt-get update\nsudo apt-get upgrade\n```\n\n注意，此时如果对sources.list文件操作不当，可能会触发如下报错：\n```\nMalformed line 1 in source list /etc/apt/sources.list (type)\nThe list of sources could not be read.\n```\n\n此时前往/etc/apt目录下，执行 sudo rm sources.list 删除文件\n之后sudo touch sources.list\n打开文件，将替换内容复制进去并保存即可。\n### 3.CLion编译环境配置\n打开CLion项目，会提示编译工具链缺失。\n\n选择环境为WSL，CLion会自动检查对应工具的缺失情况，根据报错，缺少哪个，在Ubuntu的终端中对应下载即可。\n\n至此整个流程结束，整个搭建流程还是很快速的。\n\n\n\n\n","slug":"Windows-Clion环境搭建","published":1,"updated":"2021-12-08T06:54:37.597Z","_id":"ckw56w0wh0000j8t80sob8nzw","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近开始学习网络编程，自己的Windows主机上一直没有搭建相关的开发环境，下载Clion后发现缺少一系列的编译工具链。网上查阅资料后，发现使用Windows的WSL工具，不用安装虚拟机就可以方便的拥有一个Linux环境，并且CLion也可以在这个环境下进行编译。</p>\n<p>一通尝试下来发现确实方便，Windows+WSL+CLion的工具环境轻量又好用，应该是以后在家的主要工作环境了。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"1-开启WSL\"><a href=\"#1-开启WSL\" class=\"headerlink\" title=\"1.开启WSL\"></a>1.开启WSL</h3><p>按 Win+X, 找到 Windows PowerShell (管理员)，并复制执行命令。</p>\n<p>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</p>\n<p>这个命令会激活WSL功能，之后需要重启电脑。<br>重启电脑之后，win+R，输入 appwiz.cpl，左上角找到“启动或关闭 Windows 功能”，会看到“适用于Linux的Windows子系统”选项处于选中状态。</p>\n<p>其实之前这个命令就相当于手动打开这个选中项。</p>\n<h3 id=\"2-安装WSL发行版本\"><a href=\"#2-安装WSL发行版本\" class=\"headerlink\" title=\"2.安装WSL发行版本\"></a>2.安装WSL发行版本</h3><p>在微软应用商城里搜索Ubuntu，选择一个合适的版本安装即可，这里推荐安装Ubuntu 20.04 LTS。</p>\n<p>依次获取、安装，国内网络环境下微软应用商店可能存在些延迟，耐心等一下或者翻墙下载均可。</p>\n<p>安装完后，打开Ubuntu即可，按照提示依次设置好用户名和密码即可。</p>\n<p>接下来可以进行一些Linux常规的环境配置。</p>\n<p>首先进行apt换源，我使用的是阿里云镜像。</p>\n<b>\n【⚠】首先需要备份一下sources.list文件，很重要不要跳过。\n</b>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.backup</span><br></pre></td></tr></table></figure>\n\n<p>之后执行vim /etc/apt/sources.list，替换文件内容即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiverse</span><br><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-security main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-security main restricted universe multiverse</span><br><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-updates main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-updates main restricted universe multiverse</span><br><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-proposed main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-proposed main restricted universe multiverse</span><br><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>\n\n<p>之后更新软件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>\n\n<p>注意，此时如果对sources.list文件操作不当，可能会触发如下报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Malformed line 1 in source list &#x2F;etc&#x2F;apt&#x2F;sources.list (type)</span><br><span class=\"line\">The list of sources could not be read.</span><br></pre></td></tr></table></figure>\n\n<p>此时前往/etc/apt目录下，执行 sudo rm sources.list 删除文件<br>之后sudo touch sources.list<br>打开文件，将替换内容复制进去并保存即可。</p>\n<h3 id=\"3-CLion编译环境配置\"><a href=\"#3-CLion编译环境配置\" class=\"headerlink\" title=\"3.CLion编译环境配置\"></a>3.CLion编译环境配置</h3><p>打开CLion项目，会提示编译工具链缺失。</p>\n<p>选择环境为WSL，CLion会自动检查对应工具的缺失情况，根据报错，缺少哪个，在Ubuntu的终端中对应下载即可。</p>\n<p>至此整个流程结束，整个搭建流程还是很快速的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近开始学习网络编程，自己的Windows主机上一直没有搭建相关的开发环境，下载Clion后发现缺少一系列的编译工具链。网上查阅资料后，发现使用Windows的WSL工具，不用安装虚拟机就可以方便的拥有一个Linux环境，并且CLion也可以在这个环境下进行编译。</p>\n<p>一通尝试下来发现确实方便，Windows+WSL+CLion的工具环境轻量又好用，应该是以后在家的主要工作环境了。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"1-开启WSL\"><a href=\"#1-开启WSL\" class=\"headerlink\" title=\"1.开启WSL\"></a>1.开启WSL</h3><p>按 Win+X, 找到 Windows PowerShell (管理员)，并复制执行命令。</p>\n<p>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</p>\n<p>这个命令会激活WSL功能，之后需要重启电脑。<br>重启电脑之后，win+R，输入 appwiz.cpl，左上角找到“启动或关闭 Windows 功能”，会看到“适用于Linux的Windows子系统”选项处于选中状态。</p>\n<p>其实之前这个命令就相当于手动打开这个选中项。</p>\n<h3 id=\"2-安装WSL发行版本\"><a href=\"#2-安装WSL发行版本\" class=\"headerlink\" title=\"2.安装WSL发行版本\"></a>2.安装WSL发行版本</h3><p>在微软应用商城里搜索Ubuntu，选择一个合适的版本安装即可，这里推荐安装Ubuntu 20.04 LTS。</p>\n<p>依次获取、安装，国内网络环境下微软应用商店可能存在些延迟，耐心等一下或者翻墙下载均可。</p>\n<p>安装完后，打开Ubuntu即可，按照提示依次设置好用户名和密码即可。</p>\n<p>接下来可以进行一些Linux常规的环境配置。</p>\n<p>首先进行apt换源，我使用的是阿里云镜像。</p>\n<b>\n【⚠】首先需要备份一下sources.list文件，很重要不要跳过。\n</b>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.backup</span><br></pre></td></tr></table></figure>\n\n<p>之后执行vim /etc/apt/sources.list，替换文件内容即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiverse</span><br><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-security main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-security main restricted universe multiverse</span><br><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-updates main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-updates main restricted universe multiverse</span><br><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-proposed main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-proposed main restricted universe multiverse</span><br><span class=\"line\">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>\n\n<p>之后更新软件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>\n\n<p>注意，此时如果对sources.list文件操作不当，可能会触发如下报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Malformed line 1 in source list &#x2F;etc&#x2F;apt&#x2F;sources.list (type)</span><br><span class=\"line\">The list of sources could not be read.</span><br></pre></td></tr></table></figure>\n\n<p>此时前往/etc/apt目录下，执行 sudo rm sources.list 删除文件<br>之后sudo touch sources.list<br>打开文件，将替换内容复制进去并保存即可。</p>\n<h3 id=\"3-CLion编译环境配置\"><a href=\"#3-CLion编译环境配置\" class=\"headerlink\" title=\"3.CLion编译环境配置\"></a>3.CLion编译环境配置</h3><p>打开CLion项目，会提示编译工具链缺失。</p>\n<p>选择环境为WSL，CLion会自动检查对应工具的缺失情况，根据报错，缺少哪个，在Ubuntu的终端中对应下载即可。</p>\n<p>至此整个流程结束，整个搭建流程还是很快速的。</p>\n"},{"title":"基于objc4的Runtime原理解读（一）","date":"2021-11-30T14:45:52.000Z","_content":"## 前言\n学习objective-c，runtime一直是一个绕不过去的话题，为什么iOS系统开发选择使用oc而不是c++呢？原因就是runtime这一大利器。\n\n> The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.\n\nRuntime有两个版本，一个Legacy版本 ，一个Modern版本。Legacy版本使用的是Objective-c 1，也是大多数人所了解过的runtime版本，而Modern版本则使用了Objective-c 2.0。\n- iPhone applications and 64-bit programs on OS X v10.5 and later use the modern version of the runtime.\n- Other programs (32-bit programs on OS X desktop) use the legacy version of the runtime.\n\n网上有很多资料介绍的都是Legacy版本下的runtime源码，但实际上现在已经几乎没有任何程序基于此版本的runtime执行了。\n\n接下来的内容，我将以苹果最新开源的[objc4版本的源码](https://opensource.apple.com/source/objc4/)，对runtime相关知识进行介绍。\n\n## 从类说起\n\n### objc_object\n\n```\n<objc-private.h>\n\ntypedef struct objc_class *Class;\ntypedef struct objc_object *id;\n\nstruct objc_object {\nprivate:\n    isa_t isa;\n}\n\n\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    uintptr_t bits;\n\nprivate:\n    // Accessing the class requires custom ptrauth operations, so\n    // force clients to go through setClass/getClass by making this\n    // private.\n    Class cls;\n\npublic:\n#if defined(ISA_BITFIELD)\n    struct {\n        ISA_BITFIELD;  // defined in isa.h\n    };\n\n}\n```\nobjc_object就是oc中最基础的类型，id类型其实也是一个指向objc_object类型的指针。可以看到，objc_object结构体中只有isa_t类型的isa指针。\n\n而isa_t则是一个共用体，里面不止存在指向Class类型的指针cls，还存在bits这样一个指针，使用位域技术存储了更多信息。bits指针根据不同的架构，存储了不同的内容，下面举arm64架构为例:\n```\n#     define ISA_MASK        0x0000000ffffffff8ULL\n#     define ISA_MAGIC_MASK  0x000003f000000001ULL\n#     define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#     define ISA_HAS_CXX_DTOR_BIT 1\n#     define ISA_BITFIELD                                                      \\\n        uintptr_t nonpointer        : 1;                                       \\\n        uintptr_t has_assoc         : 1;                                       \\\n        uintptr_t has_cxx_dtor      : 1;                                       \\\n        uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n        uintptr_t magic             : 6;                                       \\\n        uintptr_t weakly_referenced : 1;                                       \\\n        uintptr_t unused            : 1;                                       \\\n        uintptr_t has_sidetable_rc  : 1;                                       \\\n        uintptr_t extra_rc          : 19\n#     define RC_ONE   (1ULL<<45)\n#     define RC_HALF  (1ULL<<18)\n```\nshiftcls中存储着Class、Meta-Class对象的内存地址信息，对象的isa指针需要同ISA_MASK经过一次&（按位与)运算才能得出真正的Class对象地址。\n\nISA_MASK：  0x0000000ffffffff8ULL\n二进制：111111111111111111111111111111111000\n\n可以看出ISA_MASK最后三位的值为0，那么任何数同ISA_MASK按位与运算之后，得到的最后三位必定都为0，因此任何类对象或元类对象的内存地址最后三位必定为0，转化为十六进制末位必定为8或者0。这样是因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的0，对齐后可以提高代码运行的性能。\n\n![isa_t](isa_t.png)\n\n### Class\n\n继续查看，我们可以看到，Class其实是一个指向objc_class结构体的指针。\n```\n<objc.h>\n\ntypedef struct objc_class *Class;\n```\n\n而objc_class结构体继承自objc_object。\n\n```\n<objc-runtime-new.h>\n\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() const {\n        return bits.data();\n    }\n}\n```\n至此，我们可以得到这样一张关系图：\n\n![class](class.png)\n\n从图中我们可以看到，<b>类其实也是一个对象</b>，除了拥有一个指向类类型的isa指针外，还拥有父类指针、方法缓存和存储类数据的bits指针三个属性。\n\n下面看一下cache_t的结构，最新版的runtime源码中，_bucketsAndMaybeMask代替了之前的buckets_t指针，作为一个散列表，存储方法的imp指针。\n\n每次去寻找方法调用时，会先从对象的方法缓存中进行寻找，提高效率。\n\n```\n<objc-runtime-new.h>\n\nstruct cache_t {\nprivate:\n    explicit_atomic<uintptr_t> _bucketsAndMaybeMask;\n    union {\n        struct {\n            explicit_atomic<mask_t>    _maybeMask;\n#if __LP64__\n            uint16_t                   _flags;\n#endif\n            uint16_t                   _occupied;\n        };\n        explicit_atomic<preopt_cache_t *> _originalPreoptCache;\n    };\n    // _bucketsAndMaybeMask is a buckets_t pointer\n    // _maybeMask is the buckets mask\n}\n\n\nstruct bucket_t {\nprivate:\n    // IMP-first is better for arm64e ptrauth and no worse for arm64.\n    // SEL-first is better for armv7* and i386 and x86_64.\n#if __arm64__\n    explicit_atomic<uintptr_t> _imp;\n    explicit_atomic<SEL> _sel;\n#else\n    explicit_atomic<SEL> _sel;\n    explicit_atomic<uintptr_t> _imp;\n#endif\n}\n```\n\nclass_data_bits_t同样采用了位域技术，注释中我们可以看出，class_data_bits_t相当于class_rw_t * 加上自定义的rr/alloc标志。\n\n通过data方法取到class_rw_t。\n\n```\n<objc-runtime-new.h>\n\n#define FAST_DATA_MASK          0x00007ffffffffff8UL\n\nstruct class_data_bits_t {\n    friend objc_class;\n\n    // Values are the FAST_ flags above.\n    uintptr_t bits;\n\npublic:\n    class_rw_t* data() const {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n\n    const class_ro_t *safe_ro() const {\n        class_rw_t *maybe_rw = data();\n        if (maybe_rw->flags & RW_REALIZED) {\n            // maybe_rw is rw\n            return maybe_rw->ro();\n        } else {\n            // maybe_rw is actually ro\n            return (class_ro_t *)maybe_rw;\n        }\n    }\n}\n```\nclass_rw_t内包含了类的方法列表、属性列表和协议列表，一如其名，是可读写的（read-write)。\n\n```\n<objc-runtime-new.h>\n\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint16_t witness;\n#if SUPPORT_INDEXED_ISA\n    uint16_t index;\n#endif\n\npublic:\nconst class_ro_t *ro() const {\n        auto v = get_ro_or_rwe();\n        if (slowpath(v.is<class_rw_ext_t *>())) {\n            return v.get<class_rw_ext_t *>(&ro_or_rw_ext)->ro;\n        }\n        return v.get<const class_ro_t *>(&ro_or_rw_ext);\n\n    }\n\n    const method_array_t methods() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>(&ro_or_rw_ext)->methods;\n        } else {\n            return method_array_t{v.get<const class_ro_t *>(&ro_or_rw_ext)->baseMethods()};\n        }\n    }\n\n    const property_array_t properties() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>(&ro_or_rw_ext)->properties;\n        } else {\n            return property_array_t{v.get<const class_ro_t *>(&ro_or_rw_ext)->baseProperties};\n        }\n    }\n\n    const protocol_array_t protocols() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>(&ro_or_rw_ext)->protocols;\n        } else {\n            return protocol_array_t{v.get<const class_ro_t *>(&ro_or_rw_ext)->baseProtocols};\n        }\n    }\n}\n```\n在class_rw_t内还存储了class_ro_t指针。\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    union {\n        const uint8_t * ivarLayout;\n        Class nonMetaclass;\n    };\n\n    explicit_atomic<const char *> name;\n    // With ptrauth, this is signed if it points to a small list, but\n    // may be unsigned if it points to a big list.\n    void *baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;\n}\n```\nclass_ro_t为只读类型，存储了编译期间就确定的类的信息，包括ivar、protocol、property、method等。\n\nclass_ro_t则为读写类型，用于存储在运行时动态绑定的类的信息。\n\n在编译期间class_data_bits_t取到的data实际上为class_ro_t，此时flags指针的RW_REALIZED位为0。\n![ro](ro.png)\n\n在该类真正被实现后，class_data_bits_t取到data实际上才为class_rw_t类型。\n![rw](rw.png)\n\n## 总结\n\n我们可以用下面这张图来进行总结。\n![summary](summary.png)\n\n## 参考文稿\n\nhttps://halfrost.com/objc_runtime_isa_class/#toc-7\n\nhttps://draveness.me/method-struct/","source":"_posts/基于objc4的Runtime原理解读（一）.md","raw":"---\ntitle: 基于objc4的Runtime原理解读（一）\ndate: 2021-11-30 22:45:52\ntags: \n- iOS\n- objective-c\n- runtime\ncategories: iOS\n---\n## 前言\n学习objective-c，runtime一直是一个绕不过去的话题，为什么iOS系统开发选择使用oc而不是c++呢？原因就是runtime这一大利器。\n\n> The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.\n\nRuntime有两个版本，一个Legacy版本 ，一个Modern版本。Legacy版本使用的是Objective-c 1，也是大多数人所了解过的runtime版本，而Modern版本则使用了Objective-c 2.0。\n- iPhone applications and 64-bit programs on OS X v10.5 and later use the modern version of the runtime.\n- Other programs (32-bit programs on OS X desktop) use the legacy version of the runtime.\n\n网上有很多资料介绍的都是Legacy版本下的runtime源码，但实际上现在已经几乎没有任何程序基于此版本的runtime执行了。\n\n接下来的内容，我将以苹果最新开源的[objc4版本的源码](https://opensource.apple.com/source/objc4/)，对runtime相关知识进行介绍。\n\n## 从类说起\n\n### objc_object\n\n```\n<objc-private.h>\n\ntypedef struct objc_class *Class;\ntypedef struct objc_object *id;\n\nstruct objc_object {\nprivate:\n    isa_t isa;\n}\n\n\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    uintptr_t bits;\n\nprivate:\n    // Accessing the class requires custom ptrauth operations, so\n    // force clients to go through setClass/getClass by making this\n    // private.\n    Class cls;\n\npublic:\n#if defined(ISA_BITFIELD)\n    struct {\n        ISA_BITFIELD;  // defined in isa.h\n    };\n\n}\n```\nobjc_object就是oc中最基础的类型，id类型其实也是一个指向objc_object类型的指针。可以看到，objc_object结构体中只有isa_t类型的isa指针。\n\n而isa_t则是一个共用体，里面不止存在指向Class类型的指针cls，还存在bits这样一个指针，使用位域技术存储了更多信息。bits指针根据不同的架构，存储了不同的内容，下面举arm64架构为例:\n```\n#     define ISA_MASK        0x0000000ffffffff8ULL\n#     define ISA_MAGIC_MASK  0x000003f000000001ULL\n#     define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#     define ISA_HAS_CXX_DTOR_BIT 1\n#     define ISA_BITFIELD                                                      \\\n        uintptr_t nonpointer        : 1;                                       \\\n        uintptr_t has_assoc         : 1;                                       \\\n        uintptr_t has_cxx_dtor      : 1;                                       \\\n        uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n        uintptr_t magic             : 6;                                       \\\n        uintptr_t weakly_referenced : 1;                                       \\\n        uintptr_t unused            : 1;                                       \\\n        uintptr_t has_sidetable_rc  : 1;                                       \\\n        uintptr_t extra_rc          : 19\n#     define RC_ONE   (1ULL<<45)\n#     define RC_HALF  (1ULL<<18)\n```\nshiftcls中存储着Class、Meta-Class对象的内存地址信息，对象的isa指针需要同ISA_MASK经过一次&（按位与)运算才能得出真正的Class对象地址。\n\nISA_MASK：  0x0000000ffffffff8ULL\n二进制：111111111111111111111111111111111000\n\n可以看出ISA_MASK最后三位的值为0，那么任何数同ISA_MASK按位与运算之后，得到的最后三位必定都为0，因此任何类对象或元类对象的内存地址最后三位必定为0，转化为十六进制末位必定为8或者0。这样是因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的0，对齐后可以提高代码运行的性能。\n\n![isa_t](isa_t.png)\n\n### Class\n\n继续查看，我们可以看到，Class其实是一个指向objc_class结构体的指针。\n```\n<objc.h>\n\ntypedef struct objc_class *Class;\n```\n\n而objc_class结构体继承自objc_object。\n\n```\n<objc-runtime-new.h>\n\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() const {\n        return bits.data();\n    }\n}\n```\n至此，我们可以得到这样一张关系图：\n\n![class](class.png)\n\n从图中我们可以看到，<b>类其实也是一个对象</b>，除了拥有一个指向类类型的isa指针外，还拥有父类指针、方法缓存和存储类数据的bits指针三个属性。\n\n下面看一下cache_t的结构，最新版的runtime源码中，_bucketsAndMaybeMask代替了之前的buckets_t指针，作为一个散列表，存储方法的imp指针。\n\n每次去寻找方法调用时，会先从对象的方法缓存中进行寻找，提高效率。\n\n```\n<objc-runtime-new.h>\n\nstruct cache_t {\nprivate:\n    explicit_atomic<uintptr_t> _bucketsAndMaybeMask;\n    union {\n        struct {\n            explicit_atomic<mask_t>    _maybeMask;\n#if __LP64__\n            uint16_t                   _flags;\n#endif\n            uint16_t                   _occupied;\n        };\n        explicit_atomic<preopt_cache_t *> _originalPreoptCache;\n    };\n    // _bucketsAndMaybeMask is a buckets_t pointer\n    // _maybeMask is the buckets mask\n}\n\n\nstruct bucket_t {\nprivate:\n    // IMP-first is better for arm64e ptrauth and no worse for arm64.\n    // SEL-first is better for armv7* and i386 and x86_64.\n#if __arm64__\n    explicit_atomic<uintptr_t> _imp;\n    explicit_atomic<SEL> _sel;\n#else\n    explicit_atomic<SEL> _sel;\n    explicit_atomic<uintptr_t> _imp;\n#endif\n}\n```\n\nclass_data_bits_t同样采用了位域技术，注释中我们可以看出，class_data_bits_t相当于class_rw_t * 加上自定义的rr/alloc标志。\n\n通过data方法取到class_rw_t。\n\n```\n<objc-runtime-new.h>\n\n#define FAST_DATA_MASK          0x00007ffffffffff8UL\n\nstruct class_data_bits_t {\n    friend objc_class;\n\n    // Values are the FAST_ flags above.\n    uintptr_t bits;\n\npublic:\n    class_rw_t* data() const {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n\n    const class_ro_t *safe_ro() const {\n        class_rw_t *maybe_rw = data();\n        if (maybe_rw->flags & RW_REALIZED) {\n            // maybe_rw is rw\n            return maybe_rw->ro();\n        } else {\n            // maybe_rw is actually ro\n            return (class_ro_t *)maybe_rw;\n        }\n    }\n}\n```\nclass_rw_t内包含了类的方法列表、属性列表和协议列表，一如其名，是可读写的（read-write)。\n\n```\n<objc-runtime-new.h>\n\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint16_t witness;\n#if SUPPORT_INDEXED_ISA\n    uint16_t index;\n#endif\n\npublic:\nconst class_ro_t *ro() const {\n        auto v = get_ro_or_rwe();\n        if (slowpath(v.is<class_rw_ext_t *>())) {\n            return v.get<class_rw_ext_t *>(&ro_or_rw_ext)->ro;\n        }\n        return v.get<const class_ro_t *>(&ro_or_rw_ext);\n\n    }\n\n    const method_array_t methods() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>(&ro_or_rw_ext)->methods;\n        } else {\n            return method_array_t{v.get<const class_ro_t *>(&ro_or_rw_ext)->baseMethods()};\n        }\n    }\n\n    const property_array_t properties() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>(&ro_or_rw_ext)->properties;\n        } else {\n            return property_array_t{v.get<const class_ro_t *>(&ro_or_rw_ext)->baseProperties};\n        }\n    }\n\n    const protocol_array_t protocols() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>(&ro_or_rw_ext)->protocols;\n        } else {\n            return protocol_array_t{v.get<const class_ro_t *>(&ro_or_rw_ext)->baseProtocols};\n        }\n    }\n}\n```\n在class_rw_t内还存储了class_ro_t指针。\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    union {\n        const uint8_t * ivarLayout;\n        Class nonMetaclass;\n    };\n\n    explicit_atomic<const char *> name;\n    // With ptrauth, this is signed if it points to a small list, but\n    // may be unsigned if it points to a big list.\n    void *baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;\n}\n```\nclass_ro_t为只读类型，存储了编译期间就确定的类的信息，包括ivar、protocol、property、method等。\n\nclass_ro_t则为读写类型，用于存储在运行时动态绑定的类的信息。\n\n在编译期间class_data_bits_t取到的data实际上为class_ro_t，此时flags指针的RW_REALIZED位为0。\n![ro](ro.png)\n\n在该类真正被实现后，class_data_bits_t取到data实际上才为class_rw_t类型。\n![rw](rw.png)\n\n## 总结\n\n我们可以用下面这张图来进行总结。\n![summary](summary.png)\n\n## 参考文稿\n\nhttps://halfrost.com/objc_runtime_isa_class/#toc-7\n\nhttps://draveness.me/method-struct/","slug":"基于objc4的Runtime原理解读（一）","published":1,"updated":"2021-12-06T12:41:10.205Z","_id":"ckwm7vn0v000027mjbhlzg4zl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>学习objective-c，runtime一直是一个绕不过去的话题，为什么iOS系统开发选择使用oc而不是c++呢？原因就是runtime这一大利器。</p>\n<blockquote>\n<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>\n</blockquote>\n<p>Runtime有两个版本，一个Legacy版本 ，一个Modern版本。Legacy版本使用的是Objective-c 1，也是大多数人所了解过的runtime版本，而Modern版本则使用了Objective-c 2.0。</p>\n<ul>\n<li>iPhone applications and 64-bit programs on OS X v10.5 and later use the modern version of the runtime.</li>\n<li>Other programs (32-bit programs on OS X desktop) use the legacy version of the runtime.</li>\n</ul>\n<p>网上有很多资料介绍的都是Legacy版本下的runtime源码，但实际上现在已经几乎没有任何程序基于此版本的runtime执行了。</p>\n<p>接下来的内容，我将以苹果最新开源的<a href=\"https://opensource.apple.com/source/objc4/\">objc4版本的源码</a>，对runtime相关知识进行介绍。</p>\n<h2 id=\"从类说起\"><a href=\"#从类说起\" class=\"headerlink\" title=\"从类说起\"></a>从类说起</h2><h3 id=\"objc-object\"><a href=\"#objc-object\" class=\"headerlink\" title=\"objc_object\"></a>objc_object</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-private.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_class *Class;</span><br><span class=\"line\">typedef struct objc_object *id;</span><br><span class=\"line\"></span><br><span class=\"line\">struct objc_object &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    isa_t isa;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">union isa_t &#123;</span><br><span class=\"line\">    isa_t() &#123; &#125;</span><br><span class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    uintptr_t bits;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    &#x2F;&#x2F; Accessing the class requires custom ptrauth operations, so</span><br><span class=\"line\">    &#x2F;&#x2F; force clients to go through setClass&#x2F;getClass by making this</span><br><span class=\"line\">    &#x2F;&#x2F; private.</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">#if defined(ISA_BITFIELD)</span><br><span class=\"line\">    struct &#123;</span><br><span class=\"line\">        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>objc_object就是oc中最基础的类型，id类型其实也是一个指向objc_object类型的指针。可以看到，objc_object结构体中只有isa_t类型的isa指针。</p>\n<p>而isa_t则是一个共用体，里面不止存在指向Class类型的指针cls，还存在bits这样一个指针，使用位域技术存储了更多信息。bits指针根据不同的架构，存储了不同的内容，下面举arm64架构为例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#     define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class=\"line\">#     define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class=\"line\">#     define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class=\"line\">#     define ISA_HAS_CXX_DTOR_BIT 1</span><br><span class=\"line\">#     define ISA_BITFIELD                                                      \\</span><br><span class=\"line\">        uintptr_t nonpointer        : 1;                                       \\</span><br><span class=\"line\">        uintptr_t has_assoc         : 1;                                       \\</span><br><span class=\"line\">        uintptr_t has_cxx_dtor      : 1;                                       \\</span><br><span class=\"line\">        uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \\</span><br><span class=\"line\">        uintptr_t magic             : 6;                                       \\</span><br><span class=\"line\">        uintptr_t weakly_referenced : 1;                                       \\</span><br><span class=\"line\">        uintptr_t unused            : 1;                                       \\</span><br><span class=\"line\">        uintptr_t has_sidetable_rc  : 1;                                       \\</span><br><span class=\"line\">        uintptr_t extra_rc          : 19</span><br><span class=\"line\">#     define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class=\"line\">#     define RC_HALF  (1ULL&lt;&lt;18)</span><br></pre></td></tr></table></figure>\n<p>shiftcls中存储着Class、Meta-Class对象的内存地址信息，对象的isa指针需要同ISA_MASK经过一次&amp;（按位与)运算才能得出真正的Class对象地址。</p>\n<p>ISA_MASK：  0x0000000ffffffff8ULL<br>二进制：111111111111111111111111111111111000</p>\n<p>可以看出ISA_MASK最后三位的值为0，那么任何数同ISA_MASK按位与运算之后，得到的最后三位必定都为0，因此任何类对象或元类对象的内存地址最后三位必定为0，转化为十六进制末位必定为8或者0。这样是因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的0，对齐后可以提高代码运行的性能。</p>\n<p><img src=\"isa_t.png\" alt=\"isa_t\"></p>\n<h3 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h3><p>继续查看，我们可以看到，Class其实是一个指向objc_class结构体的指针。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>\n\n<p>而objc_class结构体继承自objc_object。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-runtime-new.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">struct objc_class : objc_object &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Class ISA;</span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class=\"line\">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class=\"line\"></span><br><span class=\"line\">    class_rw_t *data() const &#123;</span><br><span class=\"line\">        return bits.data();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，我们可以得到这样一张关系图：</p>\n<p><img src=\"class.png\" alt=\"class\"></p>\n<p>从图中我们可以看到，<b>类其实也是一个对象</b>，除了拥有一个指向类类型的isa指针外，还拥有父类指针、方法缓存和存储类数据的bits指针三个属性。</p>\n<p>下面看一下cache_t的结构，最新版的runtime源码中，_bucketsAndMaybeMask代替了之前的buckets_t指针，作为一个散列表，存储方法的imp指针。</p>\n<p>每次去寻找方法调用时，会先从对象的方法缓存中进行寻找，提高效率。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-runtime-new.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">struct cache_t &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            explicit_atomic&lt;mask_t&gt;    _maybeMask;</span><br><span class=\"line\">#if __LP64__</span><br><span class=\"line\">            uint16_t                   _flags;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">            uint16_t                   _occupied;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    &#x2F;&#x2F; _bucketsAndMaybeMask is a buckets_t pointer</span><br><span class=\"line\">    &#x2F;&#x2F; _maybeMask is the buckets mask</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">struct bucket_t &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    &#x2F;&#x2F; IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class=\"line\">    &#x2F;&#x2F; SEL-first is better for armv7* and i386 and x86_64.</span><br><span class=\"line\">#if __arm64__</span><br><span class=\"line\">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class=\"line\">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class=\"line\">#else</span><br><span class=\"line\">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class=\"line\">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>class_data_bits_t同样采用了位域技术，注释中我们可以看出，class_data_bits_t相当于class_rw_t * 加上自定义的rr/alloc标志。</p>\n<p>通过data方法取到class_rw_t。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-runtime-new.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class=\"line\"></span><br><span class=\"line\">struct class_data_bits_t &#123;</span><br><span class=\"line\">    friend objc_class;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Values are the FAST_ flags above.</span><br><span class=\"line\">    uintptr_t bits;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    class_rw_t* data() const &#123;</span><br><span class=\"line\">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const class_ro_t *safe_ro() const &#123;</span><br><span class=\"line\">        class_rw_t *maybe_rw &#x3D; data();</span><br><span class=\"line\">        if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; maybe_rw is rw</span><br><span class=\"line\">            return maybe_rw-&gt;ro();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class=\"line\">            return (class_ro_t *)maybe_rw;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>class_rw_t内包含了类的方法列表、属性列表和协议列表，一如其名，是可读写的（read-write)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-runtime-new.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">struct class_rw_t &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint16_t witness;</span><br><span class=\"line\">#if SUPPORT_INDEXED_ISA</span><br><span class=\"line\">    uint16_t index;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">const class_ro_t *ro() const &#123;</span><br><span class=\"line\">        auto v &#x3D; get_ro_or_rwe();</span><br><span class=\"line\">        if (slowpath(v.is&lt;class_rw_ext_t *&gt;())) &#123;</span><br><span class=\"line\">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;ro;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const method_array_t methods() const &#123;</span><br><span class=\"line\">        auto v &#x3D; get_ro_or_rwe();</span><br><span class=\"line\">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class=\"line\">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;methods;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const property_array_t properties() const &#123;</span><br><span class=\"line\">        auto v &#x3D; get_ro_or_rwe();</span><br><span class=\"line\">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class=\"line\">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;properties;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProperties&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const protocol_array_t protocols() const &#123;</span><br><span class=\"line\">        auto v &#x3D; get_ro_or_rwe();</span><br><span class=\"line\">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class=\"line\">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;protocols;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProtocols&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在class_rw_t内还存储了class_ro_t指针。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct class_ro_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t instanceStart;</span><br><span class=\"line\">    uint32_t instanceSize;</span><br><span class=\"line\">#ifdef __LP64__</span><br><span class=\"line\">    uint32_t reserved;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        const uint8_t * ivarLayout;</span><br><span class=\"line\">        Class nonMetaclass;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    explicit_atomic&lt;const char *&gt; name;</span><br><span class=\"line\">    &#x2F;&#x2F; With ptrauth, this is signed if it points to a small list, but</span><br><span class=\"line\">    &#x2F;&#x2F; may be unsigned if it points to a big list.</span><br><span class=\"line\">    void *baseMethodList;</span><br><span class=\"line\">    protocol_list_t * baseProtocols;</span><br><span class=\"line\">    const ivar_list_t * ivars;</span><br><span class=\"line\"></span><br><span class=\"line\">    const uint8_t * weakIvarLayout;</span><br><span class=\"line\">    property_list_t *baseProperties;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>class_ro_t为只读类型，存储了编译期间就确定的类的信息，包括ivar、protocol、property、method等。</p>\n<p>class_ro_t则为读写类型，用于存储在运行时动态绑定的类的信息。</p>\n<p>在编译期间class_data_bits_t取到的data实际上为class_ro_t，此时flags指针的RW_REALIZED位为0。<br><img src=\"ro.png\" alt=\"ro\"></p>\n<p>在该类真正被实现后，class_data_bits_t取到data实际上才为class_rw_t类型。<br><img src=\"rw.png\" alt=\"rw\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我们可以用下面这张图来进行总结。<br><img src=\"summary.png\" alt=\"summary\"></p>\n<h2 id=\"参考文稿\"><a href=\"#参考文稿\" class=\"headerlink\" title=\"参考文稿\"></a>参考文稿</h2><p><a href=\"https://halfrost.com/objc_runtime_isa_class/#toc-7\">https://halfrost.com/objc_runtime_isa_class/#toc-7</a></p>\n<p><a href=\"https://draveness.me/method-struct/\">https://draveness.me/method-struct/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>学习objective-c，runtime一直是一个绕不过去的话题，为什么iOS系统开发选择使用oc而不是c++呢？原因就是runtime这一大利器。</p>\n<blockquote>\n<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>\n</blockquote>\n<p>Runtime有两个版本，一个Legacy版本 ，一个Modern版本。Legacy版本使用的是Objective-c 1，也是大多数人所了解过的runtime版本，而Modern版本则使用了Objective-c 2.0。</p>\n<ul>\n<li>iPhone applications and 64-bit programs on OS X v10.5 and later use the modern version of the runtime.</li>\n<li>Other programs (32-bit programs on OS X desktop) use the legacy version of the runtime.</li>\n</ul>\n<p>网上有很多资料介绍的都是Legacy版本下的runtime源码，但实际上现在已经几乎没有任何程序基于此版本的runtime执行了。</p>\n<p>接下来的内容，我将以苹果最新开源的<a href=\"https://opensource.apple.com/source/objc4/\">objc4版本的源码</a>，对runtime相关知识进行介绍。</p>\n<h2 id=\"从类说起\"><a href=\"#从类说起\" class=\"headerlink\" title=\"从类说起\"></a>从类说起</h2><h3 id=\"objc-object\"><a href=\"#objc-object\" class=\"headerlink\" title=\"objc_object\"></a>objc_object</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-private.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_class *Class;</span><br><span class=\"line\">typedef struct objc_object *id;</span><br><span class=\"line\"></span><br><span class=\"line\">struct objc_object &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    isa_t isa;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">union isa_t &#123;</span><br><span class=\"line\">    isa_t() &#123; &#125;</span><br><span class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    uintptr_t bits;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    &#x2F;&#x2F; Accessing the class requires custom ptrauth operations, so</span><br><span class=\"line\">    &#x2F;&#x2F; force clients to go through setClass&#x2F;getClass by making this</span><br><span class=\"line\">    &#x2F;&#x2F; private.</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">#if defined(ISA_BITFIELD)</span><br><span class=\"line\">    struct &#123;</span><br><span class=\"line\">        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>objc_object就是oc中最基础的类型，id类型其实也是一个指向objc_object类型的指针。可以看到，objc_object结构体中只有isa_t类型的isa指针。</p>\n<p>而isa_t则是一个共用体，里面不止存在指向Class类型的指针cls，还存在bits这样一个指针，使用位域技术存储了更多信息。bits指针根据不同的架构，存储了不同的内容，下面举arm64架构为例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#     define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class=\"line\">#     define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class=\"line\">#     define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class=\"line\">#     define ISA_HAS_CXX_DTOR_BIT 1</span><br><span class=\"line\">#     define ISA_BITFIELD                                                      \\</span><br><span class=\"line\">        uintptr_t nonpointer        : 1;                                       \\</span><br><span class=\"line\">        uintptr_t has_assoc         : 1;                                       \\</span><br><span class=\"line\">        uintptr_t has_cxx_dtor      : 1;                                       \\</span><br><span class=\"line\">        uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \\</span><br><span class=\"line\">        uintptr_t magic             : 6;                                       \\</span><br><span class=\"line\">        uintptr_t weakly_referenced : 1;                                       \\</span><br><span class=\"line\">        uintptr_t unused            : 1;                                       \\</span><br><span class=\"line\">        uintptr_t has_sidetable_rc  : 1;                                       \\</span><br><span class=\"line\">        uintptr_t extra_rc          : 19</span><br><span class=\"line\">#     define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class=\"line\">#     define RC_HALF  (1ULL&lt;&lt;18)</span><br></pre></td></tr></table></figure>\n<p>shiftcls中存储着Class、Meta-Class对象的内存地址信息，对象的isa指针需要同ISA_MASK经过一次&amp;（按位与)运算才能得出真正的Class对象地址。</p>\n<p>ISA_MASK：  0x0000000ffffffff8ULL<br>二进制：111111111111111111111111111111111000</p>\n<p>可以看出ISA_MASK最后三位的值为0，那么任何数同ISA_MASK按位与运算之后，得到的最后三位必定都为0，因此任何类对象或元类对象的内存地址最后三位必定为0，转化为十六进制末位必定为8或者0。这样是因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的0，对齐后可以提高代码运行的性能。</p>\n<p><img src=\"isa_t.png\" alt=\"isa_t\"></p>\n<h3 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h3><p>继续查看，我们可以看到，Class其实是一个指向objc_class结构体的指针。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>\n\n<p>而objc_class结构体继承自objc_object。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-runtime-new.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">struct objc_class : objc_object &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Class ISA;</span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class=\"line\">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class=\"line\"></span><br><span class=\"line\">    class_rw_t *data() const &#123;</span><br><span class=\"line\">        return bits.data();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，我们可以得到这样一张关系图：</p>\n<p><img src=\"class.png\" alt=\"class\"></p>\n<p>从图中我们可以看到，<b>类其实也是一个对象</b>，除了拥有一个指向类类型的isa指针外，还拥有父类指针、方法缓存和存储类数据的bits指针三个属性。</p>\n<p>下面看一下cache_t的结构，最新版的runtime源码中，_bucketsAndMaybeMask代替了之前的buckets_t指针，作为一个散列表，存储方法的imp指针。</p>\n<p>每次去寻找方法调用时，会先从对象的方法缓存中进行寻找，提高效率。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-runtime-new.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">struct cache_t &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            explicit_atomic&lt;mask_t&gt;    _maybeMask;</span><br><span class=\"line\">#if __LP64__</span><br><span class=\"line\">            uint16_t                   _flags;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">            uint16_t                   _occupied;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    &#x2F;&#x2F; _bucketsAndMaybeMask is a buckets_t pointer</span><br><span class=\"line\">    &#x2F;&#x2F; _maybeMask is the buckets mask</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">struct bucket_t &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    &#x2F;&#x2F; IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class=\"line\">    &#x2F;&#x2F; SEL-first is better for armv7* and i386 and x86_64.</span><br><span class=\"line\">#if __arm64__</span><br><span class=\"line\">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class=\"line\">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class=\"line\">#else</span><br><span class=\"line\">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class=\"line\">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>class_data_bits_t同样采用了位域技术，注释中我们可以看出，class_data_bits_t相当于class_rw_t * 加上自定义的rr/alloc标志。</p>\n<p>通过data方法取到class_rw_t。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-runtime-new.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class=\"line\"></span><br><span class=\"line\">struct class_data_bits_t &#123;</span><br><span class=\"line\">    friend objc_class;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Values are the FAST_ flags above.</span><br><span class=\"line\">    uintptr_t bits;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    class_rw_t* data() const &#123;</span><br><span class=\"line\">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const class_ro_t *safe_ro() const &#123;</span><br><span class=\"line\">        class_rw_t *maybe_rw &#x3D; data();</span><br><span class=\"line\">        if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; maybe_rw is rw</span><br><span class=\"line\">            return maybe_rw-&gt;ro();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class=\"line\">            return (class_ro_t *)maybe_rw;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>class_rw_t内包含了类的方法列表、属性列表和协议列表，一如其名，是可读写的（read-write)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;objc-runtime-new.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">struct class_rw_t &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint16_t witness;</span><br><span class=\"line\">#if SUPPORT_INDEXED_ISA</span><br><span class=\"line\">    uint16_t index;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">const class_ro_t *ro() const &#123;</span><br><span class=\"line\">        auto v &#x3D; get_ro_or_rwe();</span><br><span class=\"line\">        if (slowpath(v.is&lt;class_rw_ext_t *&gt;())) &#123;</span><br><span class=\"line\">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;ro;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const method_array_t methods() const &#123;</span><br><span class=\"line\">        auto v &#x3D; get_ro_or_rwe();</span><br><span class=\"line\">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class=\"line\">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;methods;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const property_array_t properties() const &#123;</span><br><span class=\"line\">        auto v &#x3D; get_ro_or_rwe();</span><br><span class=\"line\">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class=\"line\">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;properties;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProperties&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const protocol_array_t protocols() const &#123;</span><br><span class=\"line\">        auto v &#x3D; get_ro_or_rwe();</span><br><span class=\"line\">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class=\"line\">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;protocols;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProtocols&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在class_rw_t内还存储了class_ro_t指针。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct class_ro_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t instanceStart;</span><br><span class=\"line\">    uint32_t instanceSize;</span><br><span class=\"line\">#ifdef __LP64__</span><br><span class=\"line\">    uint32_t reserved;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        const uint8_t * ivarLayout;</span><br><span class=\"line\">        Class nonMetaclass;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    explicit_atomic&lt;const char *&gt; name;</span><br><span class=\"line\">    &#x2F;&#x2F; With ptrauth, this is signed if it points to a small list, but</span><br><span class=\"line\">    &#x2F;&#x2F; may be unsigned if it points to a big list.</span><br><span class=\"line\">    void *baseMethodList;</span><br><span class=\"line\">    protocol_list_t * baseProtocols;</span><br><span class=\"line\">    const ivar_list_t * ivars;</span><br><span class=\"line\"></span><br><span class=\"line\">    const uint8_t * weakIvarLayout;</span><br><span class=\"line\">    property_list_t *baseProperties;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>class_ro_t为只读类型，存储了编译期间就确定的类的信息，包括ivar、protocol、property、method等。</p>\n<p>class_ro_t则为读写类型，用于存储在运行时动态绑定的类的信息。</p>\n<p>在编译期间class_data_bits_t取到的data实际上为class_ro_t，此时flags指针的RW_REALIZED位为0。<br><img src=\"ro.png\" alt=\"ro\"></p>\n<p>在该类真正被实现后，class_data_bits_t取到data实际上才为class_rw_t类型。<br><img src=\"rw.png\" alt=\"rw\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我们可以用下面这张图来进行总结。<br><img src=\"summary.png\" alt=\"summary\"></p>\n<h2 id=\"参考文稿\"><a href=\"#参考文稿\" class=\"headerlink\" title=\"参考文稿\"></a>参考文稿</h2><p><a href=\"https://halfrost.com/objc_runtime_isa_class/#toc-7\">https://halfrost.com/objc_runtime_isa_class/#toc-7</a></p>\n<p><a href=\"https://draveness.me/method-struct/\">https://draveness.me/method-struct/</a></p>\n"},{"title":"基于objc4的Runtime原理解读（二）","date":"2021-12-06T12:23:03.000Z","_content":"\n## isKindOfClass和isMemberOfClass\n直接看一下这两个方法的实现源码。\n```\n+ (BOOL)isMemberOfClass:(Class)cls {\n    return self->ISA() == cls;\n}\n\n- (BOOL)isMemberOfClass:(Class)cls {\n    return [self class] == cls;\n}\n\n+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = self->ISA(); tcls; tcls = tcls->getSuperclass()) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->getSuperclass()) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n可以看到，对于类方法和实例方法的实现是有区别的，对于类方法，通过自己的isa指针获取类类型；对于实例方法，则是通过object_getClass获取类类型。\n```\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n\nClass object_getClass(id obj)\n{\n    if (obj) return obj->getIsa();\n    else return Nil;\n}\n```\n实际上，object_getClass方法最后也是取的类对象的isa指针，那么问题来了，实例类中isa指针指向了其类对象，那么类对象的isa指针又指向了哪里呢？\n## 类与元类\n至此，“元类”的概念终于浮出水面，我们也得以明白为什么会存在元类这一概念。\n\n类对象的isa指针便指向了其元类，之所以引入元类这一概念，便是为了实例方法和类方法方法寻找逻辑上的统一。\n\n![class](class.png)\n\n正如这张经典的图片所示，实例类的isa指针指向了其类对象，而类对象的isa指针指向了其元类。所有元类的isa指针均指向了根元类NSObject，对于NSObject元类，其isa指向了自己，superclass则指向NSObject类。\n\n在查看元类时，会发现元类的名称和类对象是相同的，但是其地址是不同的，可以通过class_isMetaClass方法进行判断。\n## 测试\n```\n@interface ObjcClass : NSObject\n\n@end\n\nBOOL check1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];\nBOOL check2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];\nBOOL check3 = [(id)[ObjcClass class] isKindOfClass:[ObjcClass class]];\nBOOL check4 = [(id)[ObjcClass class] isMemberOfClass:[ObjcClass class]];\nBOOL check5 = [(id)[ObjcClass class] isKindOfClass:[NSObject class]];\nBOOL check6 = [(id)[ObjcClass class] isMemberOfClass:[NSObject class]];\n```\n对于这六个BOOL值，应该输出什么呢？\n\n结合之前的源码，+ (BOOL)isKindOfClass:(Class)cls方法内，首先判断传入的cls是否等于其元类，否则一直寻找其superclass，查看是否相等。+ (BOOL)isMemberOfClass:(Class)cls方法内，则直接判断cls的isa指针，即元类是否和cls相等。\n\n那么对于类对象来说，其isa指针和传入的类度对象本身永远不等，所以2、4、6的答案均为NO。\n\n对于check1来说，首先判断[NSObject class]是否和其元类相等，答案是否，之后判断[NSObject class]是否和其元类的superclass相等，根据上述图片可以看到相等，所以check1答案是YES。\n\n对于check3来说，首先判断[ObjcClass class]是否和其元类相等，答案是否，之后判断[ObjcClass class]是否和其元类的superclass，即NSObject元类相等，答案为否，最后判断[ObjcClass class]是否和[NSObject class]相等，答案是否，所以check3的答案是NO。\n\n对于check5来说，首先判断[NSObject class]是否和ObjcClass元类相等，答案是否，之后判断[NSObject class]是否和NSObject元类相等，答案是否，最后判断[NSObject class]是否和[NSObject class]相等，答案为是，所以check5的答案是YES。","source":"_posts/基于objc4的Runtime原理解读（二）.md","raw":"---\ntitle: 基于objc4的Runtime原理解读（二）\ndate: 2021-12-06 20:23:03\ntags:\n- runtime\n- objective-c\n- iOS\ncategories: iOS\n---\n\n## isKindOfClass和isMemberOfClass\n直接看一下这两个方法的实现源码。\n```\n+ (BOOL)isMemberOfClass:(Class)cls {\n    return self->ISA() == cls;\n}\n\n- (BOOL)isMemberOfClass:(Class)cls {\n    return [self class] == cls;\n}\n\n+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = self->ISA(); tcls; tcls = tcls->getSuperclass()) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->getSuperclass()) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n可以看到，对于类方法和实例方法的实现是有区别的，对于类方法，通过自己的isa指针获取类类型；对于实例方法，则是通过object_getClass获取类类型。\n```\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n\nClass object_getClass(id obj)\n{\n    if (obj) return obj->getIsa();\n    else return Nil;\n}\n```\n实际上，object_getClass方法最后也是取的类对象的isa指针，那么问题来了，实例类中isa指针指向了其类对象，那么类对象的isa指针又指向了哪里呢？\n## 类与元类\n至此，“元类”的概念终于浮出水面，我们也得以明白为什么会存在元类这一概念。\n\n类对象的isa指针便指向了其元类，之所以引入元类这一概念，便是为了实例方法和类方法方法寻找逻辑上的统一。\n\n![class](class.png)\n\n正如这张经典的图片所示，实例类的isa指针指向了其类对象，而类对象的isa指针指向了其元类。所有元类的isa指针均指向了根元类NSObject，对于NSObject元类，其isa指向了自己，superclass则指向NSObject类。\n\n在查看元类时，会发现元类的名称和类对象是相同的，但是其地址是不同的，可以通过class_isMetaClass方法进行判断。\n## 测试\n```\n@interface ObjcClass : NSObject\n\n@end\n\nBOOL check1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];\nBOOL check2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];\nBOOL check3 = [(id)[ObjcClass class] isKindOfClass:[ObjcClass class]];\nBOOL check4 = [(id)[ObjcClass class] isMemberOfClass:[ObjcClass class]];\nBOOL check5 = [(id)[ObjcClass class] isKindOfClass:[NSObject class]];\nBOOL check6 = [(id)[ObjcClass class] isMemberOfClass:[NSObject class]];\n```\n对于这六个BOOL值，应该输出什么呢？\n\n结合之前的源码，+ (BOOL)isKindOfClass:(Class)cls方法内，首先判断传入的cls是否等于其元类，否则一直寻找其superclass，查看是否相等。+ (BOOL)isMemberOfClass:(Class)cls方法内，则直接判断cls的isa指针，即元类是否和cls相等。\n\n那么对于类对象来说，其isa指针和传入的类度对象本身永远不等，所以2、4、6的答案均为NO。\n\n对于check1来说，首先判断[NSObject class]是否和其元类相等，答案是否，之后判断[NSObject class]是否和其元类的superclass相等，根据上述图片可以看到相等，所以check1答案是YES。\n\n对于check3来说，首先判断[ObjcClass class]是否和其元类相等，答案是否，之后判断[ObjcClass class]是否和其元类的superclass，即NSObject元类相等，答案为否，最后判断[ObjcClass class]是否和[NSObject class]相等，答案是否，所以check3的答案是NO。\n\n对于check5来说，首先判断[NSObject class]是否和ObjcClass元类相等，答案是否，之后判断[NSObject class]是否和NSObject元类相等，答案是否，最后判断[NSObject class]是否和[NSObject class]相等，答案为是，所以check5的答案是YES。","slug":"基于objc4的Runtime原理解读（二）","published":1,"updated":"2021-12-07T15:06:21.918Z","_id":"ckwunoxbf00020bmjhcgaapk0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"isKindOfClass和isMemberOfClass\"><a href=\"#isKindOfClass和isMemberOfClass\" class=\"headerlink\" title=\"isKindOfClass和isMemberOfClass\"></a>isKindOfClass和isMemberOfClass</h2><p>直接看一下这两个方法的实现源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class=\"line\">    return self-&gt;ISA() &#x3D;&#x3D; cls;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class=\"line\">    return [self class] &#x3D;&#x3D; cls;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class=\"line\">    for (Class tcls &#x3D; self-&gt;ISA(); tcls; tcls &#x3D; tcls-&gt;getSuperclass()) &#123;</span><br><span class=\"line\">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class=\"line\">    for (Class tcls &#x3D; [self class]; tcls; tcls &#x3D; tcls-&gt;getSuperclass()) &#123;</span><br><span class=\"line\">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，对于类方法和实例方法的实现是有区别的，对于类方法，通过自己的isa指针获取类类型；对于实例方法，则是通过object_getClass获取类类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Class)class &#123;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (Class)class &#123;</span><br><span class=\"line\">    return object_getClass(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Class object_getClass(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (obj) return obj-&gt;getIsa();</span><br><span class=\"line\">    else return Nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，object_getClass方法最后也是取的类对象的isa指针，那么问题来了，实例类中isa指针指向了其类对象，那么类对象的isa指针又指向了哪里呢？</p>\n<h2 id=\"类与元类\"><a href=\"#类与元类\" class=\"headerlink\" title=\"类与元类\"></a>类与元类</h2><p>至此，“元类”的概念终于浮出水面，我们也得以明白为什么会存在元类这一概念。</p>\n<p>类对象的isa指针便指向了其元类，之所以引入元类这一概念，便是为了实例方法和类方法方法寻找逻辑上的统一。</p>\n<p><img src=\"class.png\" alt=\"class\"></p>\n<p>正如这张经典的图片所示，实例类的isa指针指向了其类对象，而类对象的isa指针指向了其元类。所有元类的isa指针均指向了根元类NSObject，对于NSObject元类，其isa指向了自己，superclass则指向NSObject类。</p>\n<p>在查看元类时，会发现元类的名称和类对象是相同的，但是其地址是不同的，可以通过class_isMetaClass方法进行判断。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ObjcClass : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL check1 &#x3D; [(id)[NSObject class] isKindOfClass:[NSObject class]];</span><br><span class=\"line\">BOOL check2 &#x3D; [(id)[NSObject class] isMemberOfClass:[NSObject class]];</span><br><span class=\"line\">BOOL check3 &#x3D; [(id)[ObjcClass class] isKindOfClass:[ObjcClass class]];</span><br><span class=\"line\">BOOL check4 &#x3D; [(id)[ObjcClass class] isMemberOfClass:[ObjcClass class]];</span><br><span class=\"line\">BOOL check5 &#x3D; [(id)[ObjcClass class] isKindOfClass:[NSObject class]];</span><br><span class=\"line\">BOOL check6 &#x3D; [(id)[ObjcClass class] isMemberOfClass:[NSObject class]];</span><br></pre></td></tr></table></figure>\n<p>对于这六个BOOL值，应该输出什么呢？</p>\n<p>结合之前的源码，+ (BOOL)isKindOfClass:(Class)cls方法内，首先判断传入的cls是否等于其元类，否则一直寻找其superclass，查看是否相等。+ (BOOL)isMemberOfClass:(Class)cls方法内，则直接判断cls的isa指针，即元类是否和cls相等。</p>\n<p>那么对于类对象来说，其isa指针和传入的类度对象本身永远不等，所以2、4、6的答案均为NO。</p>\n<p>对于check1来说，首先判断[NSObject class]是否和其元类相等，答案是否，之后判断[NSObject class]是否和其元类的superclass相等，根据上述图片可以看到相等，所以check1答案是YES。</p>\n<p>对于check3来说，首先判断[ObjcClass class]是否和其元类相等，答案是否，之后判断[ObjcClass class]是否和其元类的superclass，即NSObject元类相等，答案为否，最后判断[ObjcClass class]是否和[NSObject class]相等，答案是否，所以check3的答案是NO。</p>\n<p>对于check5来说，首先判断[NSObject class]是否和ObjcClass元类相等，答案是否，之后判断[NSObject class]是否和NSObject元类相等，答案是否，最后判断[NSObject class]是否和[NSObject class]相等，答案为是，所以check5的答案是YES。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"isKindOfClass和isMemberOfClass\"><a href=\"#isKindOfClass和isMemberOfClass\" class=\"headerlink\" title=\"isKindOfClass和isMemberOfClass\"></a>isKindOfClass和isMemberOfClass</h2><p>直接看一下这两个方法的实现源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class=\"line\">    return self-&gt;ISA() &#x3D;&#x3D; cls;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class=\"line\">    return [self class] &#x3D;&#x3D; cls;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class=\"line\">    for (Class tcls &#x3D; self-&gt;ISA(); tcls; tcls &#x3D; tcls-&gt;getSuperclass()) &#123;</span><br><span class=\"line\">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class=\"line\">    for (Class tcls &#x3D; [self class]; tcls; tcls &#x3D; tcls-&gt;getSuperclass()) &#123;</span><br><span class=\"line\">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，对于类方法和实例方法的实现是有区别的，对于类方法，通过自己的isa指针获取类类型；对于实例方法，则是通过object_getClass获取类类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Class)class &#123;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (Class)class &#123;</span><br><span class=\"line\">    return object_getClass(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Class object_getClass(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (obj) return obj-&gt;getIsa();</span><br><span class=\"line\">    else return Nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，object_getClass方法最后也是取的类对象的isa指针，那么问题来了，实例类中isa指针指向了其类对象，那么类对象的isa指针又指向了哪里呢？</p>\n<h2 id=\"类与元类\"><a href=\"#类与元类\" class=\"headerlink\" title=\"类与元类\"></a>类与元类</h2><p>至此，“元类”的概念终于浮出水面，我们也得以明白为什么会存在元类这一概念。</p>\n<p>类对象的isa指针便指向了其元类，之所以引入元类这一概念，便是为了实例方法和类方法方法寻找逻辑上的统一。</p>\n<p><img src=\"class.png\" alt=\"class\"></p>\n<p>正如这张经典的图片所示，实例类的isa指针指向了其类对象，而类对象的isa指针指向了其元类。所有元类的isa指针均指向了根元类NSObject，对于NSObject元类，其isa指向了自己，superclass则指向NSObject类。</p>\n<p>在查看元类时，会发现元类的名称和类对象是相同的，但是其地址是不同的，可以通过class_isMetaClass方法进行判断。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ObjcClass : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL check1 &#x3D; [(id)[NSObject class] isKindOfClass:[NSObject class]];</span><br><span class=\"line\">BOOL check2 &#x3D; [(id)[NSObject class] isMemberOfClass:[NSObject class]];</span><br><span class=\"line\">BOOL check3 &#x3D; [(id)[ObjcClass class] isKindOfClass:[ObjcClass class]];</span><br><span class=\"line\">BOOL check4 &#x3D; [(id)[ObjcClass class] isMemberOfClass:[ObjcClass class]];</span><br><span class=\"line\">BOOL check5 &#x3D; [(id)[ObjcClass class] isKindOfClass:[NSObject class]];</span><br><span class=\"line\">BOOL check6 &#x3D; [(id)[ObjcClass class] isMemberOfClass:[NSObject class]];</span><br></pre></td></tr></table></figure>\n<p>对于这六个BOOL值，应该输出什么呢？</p>\n<p>结合之前的源码，+ (BOOL)isKindOfClass:(Class)cls方法内，首先判断传入的cls是否等于其元类，否则一直寻找其superclass，查看是否相等。+ (BOOL)isMemberOfClass:(Class)cls方法内，则直接判断cls的isa指针，即元类是否和cls相等。</p>\n<p>那么对于类对象来说，其isa指针和传入的类度对象本身永远不等，所以2、4、6的答案均为NO。</p>\n<p>对于check1来说，首先判断[NSObject class]是否和其元类相等，答案是否，之后判断[NSObject class]是否和其元类的superclass相等，根据上述图片可以看到相等，所以check1答案是YES。</p>\n<p>对于check3来说，首先判断[ObjcClass class]是否和其元类相等，答案是否，之后判断[ObjcClass class]是否和其元类的superclass，即NSObject元类相等，答案为否，最后判断[ObjcClass class]是否和[NSObject class]相等，答案是否，所以check3的答案是NO。</p>\n<p>对于check5来说，首先判断[NSObject class]是否和ObjcClass元类相等，答案是否，之后判断[NSObject class]是否和NSObject元类相等，答案是否，最后判断[NSObject class]是否和[NSObject class]相等，答案为是，所以check5的答案是YES。</p>\n"},{"title":"Linux高效文件处理命令——grep","date":"2021-12-14T13:23:18.000Z","_content":"\n## 前言\n\n### MacOS环境配置GNU版本grep\nMacOS环境下自带grep命令，不过是BSD版本，使用`grep --version`命令即可查看版本。\n\n该版本对-r -p等参数不支持，需要安装GNU版本的grep命令才可执行。\n\n直接使用Homebrew进行安装即可。\n```\nbrew install grep\n```\n网上很多教程说要携带`--with-default-names`参数进行grep命令覆盖，但此参数已经被废弃，无法使用。\n\n题外话，如果Homebrew提示需要更新CLT版本，执行`brew update-reset`即可。\n\n安装完GNU版本grep后，需要更新一下对应的`.bashrc`或者`.zshrc`文件。\n```\nexport PATH=\"/usr/local/opt/grep/libexec/gnubin:$PATH\"\n```\n添加完成后对应执行`source .bashrc/.zshrc`便成功完成替换，此时再次输入`grep --version`看到输出为GNU版本即为替换成功。\n\n### grep命令\n\n基础命令格式如下\n```\ngrep [OPTION] PATTERNS [FILE]\n```\n也可以配合管道命令｜一起使用\n```\n[FILE] | grep [OPTION] PATTERNS\n```\n`PATTERNS`为要查询的匹配串，支持正则表达式。\n\n`OPTION`为命令参数，可以输入多个，常用的参数如下：\n\n`-B(NUM),  --before-context=NUM`\n输出匹配行的前NUM行\n\n`-A(NUM),  --after-context=NUM`\n输出匹配行的后NUM行\n\n`-C(NUM),  --context=NUM`\n输出匹配行的前后NUM行\n\n`-r`\n\n`grep -r [PATTERN] .`\n在当前目录下递归搜索PATTERN，可以再添加--exclude-from=FILE或者--exclude-dir=GLOB进行过滤。\n\n`-v`\n相当于not操作，查询不包含PATTERN的内容\n\n`-c` \n输出文件匹配PATTERN的总行数\n\n`-n`\n输出文件匹配PATTERN的所在行数\n\n`grep [PATTERN1 \\| PATTERN2] [FILE]`\n使用\\|符号匹配多个PATTERN\n\n\n### 参考文稿\n\n[macOS 使用 GNU 命令](https://blog.cotes.info/posts/use-gnu-utilities-in-mac/)","source":"_posts/Linux高效文件处理命令——grep.md","raw":"---\ntitle: Linux高效文件处理命令——grep\ntags:\n  - Linux\n  - 终端\ndate: 2021-12-14 21:23:18\ncategories: Linux\n---\n\n## 前言\n\n### MacOS环境配置GNU版本grep\nMacOS环境下自带grep命令，不过是BSD版本，使用`grep --version`命令即可查看版本。\n\n该版本对-r -p等参数不支持，需要安装GNU版本的grep命令才可执行。\n\n直接使用Homebrew进行安装即可。\n```\nbrew install grep\n```\n网上很多教程说要携带`--with-default-names`参数进行grep命令覆盖，但此参数已经被废弃，无法使用。\n\n题外话，如果Homebrew提示需要更新CLT版本，执行`brew update-reset`即可。\n\n安装完GNU版本grep后，需要更新一下对应的`.bashrc`或者`.zshrc`文件。\n```\nexport PATH=\"/usr/local/opt/grep/libexec/gnubin:$PATH\"\n```\n添加完成后对应执行`source .bashrc/.zshrc`便成功完成替换，此时再次输入`grep --version`看到输出为GNU版本即为替换成功。\n\n### grep命令\n\n基础命令格式如下\n```\ngrep [OPTION] PATTERNS [FILE]\n```\n也可以配合管道命令｜一起使用\n```\n[FILE] | grep [OPTION] PATTERNS\n```\n`PATTERNS`为要查询的匹配串，支持正则表达式。\n\n`OPTION`为命令参数，可以输入多个，常用的参数如下：\n\n`-B(NUM),  --before-context=NUM`\n输出匹配行的前NUM行\n\n`-A(NUM),  --after-context=NUM`\n输出匹配行的后NUM行\n\n`-C(NUM),  --context=NUM`\n输出匹配行的前后NUM行\n\n`-r`\n\n`grep -r [PATTERN] .`\n在当前目录下递归搜索PATTERN，可以再添加--exclude-from=FILE或者--exclude-dir=GLOB进行过滤。\n\n`-v`\n相当于not操作，查询不包含PATTERN的内容\n\n`-c` \n输出文件匹配PATTERN的总行数\n\n`-n`\n输出文件匹配PATTERN的所在行数\n\n`grep [PATTERN1 \\| PATTERN2] [FILE]`\n使用\\|符号匹配多个PATTERN\n\n\n### 参考文稿\n\n[macOS 使用 GNU 命令](https://blog.cotes.info/posts/use-gnu-utilities-in-mac/)","slug":"Linux高效文件处理命令——grep","published":1,"updated":"2021-12-15T08:29:45.135Z","_id":"ckx64y36y0000d2mjc63h51r3","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h3 id=\"MacOS环境配置GNU版本grep\"><a href=\"#MacOS环境配置GNU版本grep\" class=\"headerlink\" title=\"MacOS环境配置GNU版本grep\"></a>MacOS环境配置GNU版本grep</h3><p>MacOS环境下自带grep命令，不过是BSD版本，使用<code>grep --version</code>命令即可查看版本。</p>\n<p>该版本对-r -p等参数不支持，需要安装GNU版本的grep命令才可执行。</p>\n<p>直接使用Homebrew进行安装即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install grep</span><br></pre></td></tr></table></figure>\n<p>网上很多教程说要携带<code>--with-default-names</code>参数进行grep命令覆盖，但此参数已经被废弃，无法使用。</p>\n<p>题外话，如果Homebrew提示需要更新CLT版本，执行<code>brew update-reset</code>即可。</p>\n<p>安装完GNU版本grep后，需要更新一下对应的<code>.bashrc</code>或者<code>.zshrc</code>文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;grep&#x2F;libexec&#x2F;gnubin:$PATH&quot;</span><br></pre></td></tr></table></figure>\n<p>添加完成后对应执行<code>source .bashrc/.zshrc</code>便成功完成替换，此时再次输入<code>grep --version</code>看到输出为GNU版本即为替换成功。</p>\n<h3 id=\"grep命令\"><a href=\"#grep命令\" class=\"headerlink\" title=\"grep命令\"></a>grep命令</h3><p>基础命令格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [OPTION] PATTERNS [FILE]</span><br></pre></td></tr></table></figure>\n<p>也可以配合管道命令｜一起使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[FILE] | grep [OPTION] PATTERNS</span><br></pre></td></tr></table></figure>\n<p><code>PATTERNS</code>为要查询的匹配串，支持正则表达式。</p>\n<p><code>OPTION</code>为命令参数，可以输入多个，常用的参数如下：</p>\n<p><code>-B(NUM),  --before-context=NUM</code><br>输出匹配行的前NUM行</p>\n<p><code>-A(NUM),  --after-context=NUM</code><br>输出匹配行的后NUM行</p>\n<p><code>-C(NUM),  --context=NUM</code><br>输出匹配行的前后NUM行</p>\n<p><code>-r</code></p>\n<p><code>grep -r [PATTERN] .</code><br>在当前目录下递归搜索PATTERN，可以再添加–exclude-from=FILE或者–exclude-dir=GLOB进行过滤。</p>\n<p><code>-v</code><br>相当于not操作，查询不包含PATTERN的内容</p>\n<p><code>-c</code><br>输出文件匹配PATTERN的总行数</p>\n<p><code>-n</code><br>输出文件匹配PATTERN的所在行数</p>\n<p><code>grep [PATTERN1 \\| PATTERN2] [FILE]</code><br>使用|符号匹配多个PATTERN</p>\n<h3 id=\"参考文稿\"><a href=\"#参考文稿\" class=\"headerlink\" title=\"参考文稿\"></a>参考文稿</h3><p><a href=\"https://blog.cotes.info/posts/use-gnu-utilities-in-mac/\">macOS 使用 GNU 命令</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h3 id=\"MacOS环境配置GNU版本grep\"><a href=\"#MacOS环境配置GNU版本grep\" class=\"headerlink\" title=\"MacOS环境配置GNU版本grep\"></a>MacOS环境配置GNU版本grep</h3><p>MacOS环境下自带grep命令，不过是BSD版本，使用<code>grep --version</code>命令即可查看版本。</p>\n<p>该版本对-r -p等参数不支持，需要安装GNU版本的grep命令才可执行。</p>\n<p>直接使用Homebrew进行安装即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install grep</span><br></pre></td></tr></table></figure>\n<p>网上很多教程说要携带<code>--with-default-names</code>参数进行grep命令覆盖，但此参数已经被废弃，无法使用。</p>\n<p>题外话，如果Homebrew提示需要更新CLT版本，执行<code>brew update-reset</code>即可。</p>\n<p>安装完GNU版本grep后，需要更新一下对应的<code>.bashrc</code>或者<code>.zshrc</code>文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;grep&#x2F;libexec&#x2F;gnubin:$PATH&quot;</span><br></pre></td></tr></table></figure>\n<p>添加完成后对应执行<code>source .bashrc/.zshrc</code>便成功完成替换，此时再次输入<code>grep --version</code>看到输出为GNU版本即为替换成功。</p>\n<h3 id=\"grep命令\"><a href=\"#grep命令\" class=\"headerlink\" title=\"grep命令\"></a>grep命令</h3><p>基础命令格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [OPTION] PATTERNS [FILE]</span><br></pre></td></tr></table></figure>\n<p>也可以配合管道命令｜一起使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[FILE] | grep [OPTION] PATTERNS</span><br></pre></td></tr></table></figure>\n<p><code>PATTERNS</code>为要查询的匹配串，支持正则表达式。</p>\n<p><code>OPTION</code>为命令参数，可以输入多个，常用的参数如下：</p>\n<p><code>-B(NUM),  --before-context=NUM</code><br>输出匹配行的前NUM行</p>\n<p><code>-A(NUM),  --after-context=NUM</code><br>输出匹配行的后NUM行</p>\n<p><code>-C(NUM),  --context=NUM</code><br>输出匹配行的前后NUM行</p>\n<p><code>-r</code></p>\n<p><code>grep -r [PATTERN] .</code><br>在当前目录下递归搜索PATTERN，可以再添加–exclude-from=FILE或者–exclude-dir=GLOB进行过滤。</p>\n<p><code>-v</code><br>相当于not操作，查询不包含PATTERN的内容</p>\n<p><code>-c</code><br>输出文件匹配PATTERN的总行数</p>\n<p><code>-n</code><br>输出文件匹配PATTERN的所在行数</p>\n<p><code>grep [PATTERN1 \\| PATTERN2] [FILE]</code><br>使用|符号匹配多个PATTERN</p>\n<h3 id=\"参考文稿\"><a href=\"#参考文稿\" class=\"headerlink\" title=\"参考文稿\"></a>参考文稿</h3><p><a href=\"https://blog.cotes.info/posts/use-gnu-utilities-in-mac/\">macOS 使用 GNU 命令</a></p>\n"},{"title":"聊聊动态链接","date":"2023-02-16T13:17:52.000Z","_content":"## 前言\n不深入涉及dyld源码的前提下，介绍一下动态链接的概念及原理，在iOS系统上的实现及应用。\n一些需要提前了解的知识点：\n**静态链接**\n- 最初始的应用程序只有一个文件，编译过程就是一个源文件到可执行文件的翻译。\n![static_linker_1](static_linker_1.png)\n- 随着应用程序的复杂度和规模不断增加，程序源码被拆分到多个文件，此时需要对多个目标文件的编译产物进行整合，最终产出一个可执行文件，静态链接器就此出现。\n![static_linker_2](static_linker_2.png)\n- 当一个应用程序的源文件增长到几千上万个时，每次改动后对所有源码进行编译变得非常耗时，此时静态库和ar工具应运而生。\nar工具把多个.o产物打包成一个.a静态库，链接器再将.a静态库和.o文件链接成可执行文件，这样避免了重复编译工作。\n![static_linker_3](static_linker_3.png)\n**ELF文件格式 / Mach-O文件格式 / DEX文件格式**\n- 所有的mach-o文件都包含了一个或多个数据段（Segment），每一个数据段都包含了零个或者多个段落（Section），每个section包含了一些特定类型的代码或者数据，数据段准确的数量以及布局由加载命令和文件类型决定。\n![mach-o](mach-o.png)\n\n## 背景\n静态链接存在的缺点：\n- 内存空间占用大，当多个目标文件需要链接相同的库时，会造成内存资源的浪费\n- 程序兼容性差，当其中一个链接的目标文件更新后，整个程序需要重新编译一遍，无法做到动态更新\n\n## 基本思想\n系统全局仅存在一份动态链接库文件，程序运行时再进行链接。\n![dyld-1](dyld-1.png)\n\n## 原理\n\n### 装载时重定位（Rebasing）\n静态链接通过重定位进行符号寻址，在静态链接器完成空间与地址分配后，便能确定所有目标符号的虚拟地址，对目标文件的外部符号进行重定位修正，这一步可以被称为链接时重定位。\n但是静态链接的重定位方法并不适合动态链接库，动态链接库是在程序运行时才被加载至内存，当程序调用动态链接库文件代码段的绝对地址时，每个程序的重定位偏移量都会不同，没法做到多个程序共享同一份重定位后的动态链接库文件。\n\n**地址无关代码PIC （Position Independent Code）**\n前提：ELF文件格式\n- 一个模块前面是若干页可读代码段，后面是若干页读写数据段\n- 在一个模块内，任何一条指令与其访问的数据之间的相对位置是固定的\n我们期望动态链接库共享的指令在动态库装载时不需要因为装载地址的改变而改变，把那些需要重定位修改的部分抽离出来，与数据段放在一起。\n这样动态链接库指令部分保持不变，被多个程序共享，数据部分则在每个程序进程中存在一份副本。\n- 分类\n  - 模块内部的函数调用\n    - 处于同一个模块，相对地址固定，不需要重定位\n  - 模块内部的数据访问\n    - 指令中不能包含数据的绝对地址，只能进行相对寻址，当前指令加上一个偏移量即可访问\n  - 模块外部的数据访问\n    - 模块外部的数据访问需要等到装载时才能确定，处理思想是把与地址相关的部分放到数据段中\n    - 在数据段中建立全局偏移表GOT（Global Offset Table），代码指令需要访问外部变量时，首先访问GOT中的对应项，在装载时重定位修改GOT的偏移量，找到变量的目标地址\n    - 同模块内部数据访问一样，我们可以知道GOT与代码指令之间的相对位置固定\n  - 模块外部的函数调用\n    - 同样使用GOT，GOT中保存的是目标函数的地址\n- 总结\n\n|  | 指令跳转、调用   | 数据访问 |\n| :--: | :--: | :--: | \n| **模块内部** | 相对跳转和调用 |  相对地址访问  | \n| **模块外部** | 间接跳转和调用（GOT） |  间接访问（GOT）  | \n\n- 还有一个问题\n  - 编译器无法区分一个外部全局变量是否是模块外部调用还是内部调用\n  - 默认按照模块外部全局变量进行调用\n    - 即使用GOT\n\n### 性能损耗\n- 原因\n  - 对于全局和静态的数据访问即模块间的调用都需要进行复杂的GOT定位，间接调用\n  - 动态链接的链接工作是在运行时完成的，即程序开始执行时，动态链接器都要进行一次链接工作\n- 优化\n  - 延迟绑定\n    - 将动态链接从程序启动时进行推迟到当函数第一次被调用时进行\n    - PLT （Procedure Linkage Table）\n- 本质是一个方法跳转\n- 方法重定位后会将地址存入bar@plt\n- bar@plt最开始被初始化为push n，即执行下一条指令\n- _dl_runtime_resolve进行重定位，将方法真正地址写入bar@plt\n![dyld](dyld-2.png)\n\n## iOS动态链接过程\n动态链接所需要的信息记录在这个LC_DYLD_INFO_ONLY这个load command中，包括了Rebase Info、Binding Info、Weak Binding Info、Lazy Binding Info和Export Info五部分内容。\n![dyld](dyld-3.png)\n\n### Rebase\n>Address space layout randomization (ASLR) is a computer security technique involved in preventing exploitation of memory corruption vulnerabilities. In order to prevent an attacker from reliably jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the base of the executable and the positions of the stack, heap and libraries.\n\n地址空间布局随机化（ASLR）是一种计算机安全技术，可防止利用内存进行漏洞攻击。为了防止攻击者可以依靠地址跳转到内存中的某个特定程序段利用功能，ASLR会随机排列进程的关键数据区域的地址，包括可执行文件、堆栈和库的地址。\n对内部指针进行调整，Mach-O文件映射到内存中时，ASLR会进行一个随机偏移，所以需要对内部指针进行调整。\n\n### Bind\n对预留的外部指针进行绑定。\n\n#### Non-lazy binding\n在程序启动时，dyld便通过重定位确定好需动态链接符号的地址。\n在__DATA.__got段中存储所有non-lazy symbol pointers。\n\n#### Lazy binding\n当符号首次被调用时，dyld才进行符号绑定操作。\nDyld Lazy binding过程详解 \n![dyld](dyld-4.png)\n![dyld](dyld-5.png)\n总结一下流程：\n1. 首次调用TEXT.__stub段方法，跳转到对应的DATA.__la_symbol_ptr 方法\n2.  DATA.__la_symbol_ptr 中方法最开始指向到 TEXT.__stub_helper\n3. TEXT.__stub_helper跳转到libdyld.dylib文件__TEXT段的dyld_stub_binder方法\n4. dyld内部调用到_dyld_func_lookup方法动态链接到对应方法，并修改对应的__la_symbol_ptr段\n5. 再次调用，由TEXT.__stub段跳转至DATA.__la_symbol_ptr，直接调用对应方法\n\n#### CHAIEND FIXUPS\n上述Rebase & Bind的过程分析在很多博客中都有过解析，但是我们此时再新建一个工程尝试复刻时，会发现DATA段中的__la_symbol_ptr消失了，这是怎么一回事呢？\n因为目前新建工程时默认的Minimum Deployments为iOS15.0，苹果使用了CHAINED_FIXUPS取代了之前Rebase & Bind机制。苹果在今年的WWDC session中宣称这项优化实际在iOS13.4及之后的版本便已支持。测试来看仅在Minimum Deployments>=15.0时，Mach-O文件格式会发生变化。\n使用CHAINED_FIXUPS的Mach-O会在load command中使用LC_DYLD_CHAINED_FIXUPS和LC_DYLD_EXPORTS_TRIE代替LC_DYLD_INFO_ONLY。\n\n![dyld](dyld-6.png)\n回顾Rebase & Bind过程，不免发现它存在着几个缺点：\n1. Rebase和Bind操作对Mach-O文件进行了两次遍历，可能对某些段进行了重复访问，iOS系统会对较长时间没有用到的page进行压缩处理，两遍遍历导致了额外的page压缩与解压缩操作，增加耗时的同时没有利用到空间局部性；\n2. 用于存放Rebase和Bind信息的LINKEDIT段在动态链接完成后失去了作用，但仍占用了Mach-O文件的体积，如果能对这部分空间重复利用的话可以减少包体积。\n   \nChained Fixups实际上采用链表的方式来将rebase和bind的信息整合到一起，需要进行Rebase/Bind的符号不再被记录到__LINKEDIT中，而是以链表的形式记录到__DATA 段中，__LINKEDIT段仅记录需要修复的segment表头。\n![dyld](dyld-7.png)\n![dyld](dyld-8.png)\n>不使用Chained Fixups：\n![dyld](dyld-9.png)\n![dyld](dyld-10.png)\n使用Chined Fixups：\n![dyld](dyld-11.png)\n\n对比可以发现，使用Chained Fixups的Mach-O文件DATA段不再保存__la_symbol_ptr，全部使用__got段存储需动态链接的符号，且不再使用空指针占位，而是保存了链表信息，实际是存放了64位大小的 ChainedFixupPointerOnDisk union（可以是 dyld_chained_ptr_64_rebase，dyld_chained_ptr_64_bind，或者其它类型的fixup chain节点），而 dyld 则会利用这部分信息进行 rebase&bind。 \n总体来说，Chained fixup方案中，dyld不需要再去一边读取LINKEDIT段信息一遍做rebase&bind操作，而是直接沿着链表逐个读取节点，这样dyld即可在一次遍历中完成rebase及bind操作，减少了不必要的page压缩及解压缩操作，利用了空间局限性，减少了耗时。\n\n#### Page-in Linking\n今年的WWDC，苹果又公布了dyld的一项新功能，Page-in Linking。和过去 dyld 在启动时一次性统一修正所有的动态链接库符号不同，dyld现在可以在 page-in 的时候去自动修正 DATA 段内的 page。一直以来，内核都可以通过 mmap() 来访问 page，但是现在，如果它是一个 DATA page，内核在访问的同时还会顺便对其进行 fixup，这种机制减少了脏内存和启动时间，这也意味着 DATA_CONST 段的page是干净的，它们可以像 TEXT 页面一样被暂时移出内存和重新创建，从而减少内存压力。但 page-in linking 只适用于用 chained fixups 构建的二进制文件。这是因为在 chained fixups 中，大部分修复信息将被编码在磁盘上的 DATA 段中，这意味着在 page-in 时内核可以使用这些信息。\n有一点需要注意的是，dyld 只会在应用启动时使用这一机制。任何后来被 dlopen() 打开的 dylibs 都不会进行 page-in linking。在这种情况下，dyld 会采用传统的方法，在调用 dlopen 时应用 fixup。\n![dyld](dyld-12.png)\n\n## 动态链接在APP中的应用\niOS系统层面实际上运用了大量的动态链接库，可以在App的Mach-O文件的Load Commands中查看所有LC_LOAD_DYLIB动态库。\n![dyld](dyld-13.png)\n但是对于APP来说，只能引入App内签名的动态库和系统签名的动态库，并不能如愿的引入第三方发布的动态链接库，原因在于dyld内部禁止加载非App签名的image文件，尝试加载会触发crashIfInvalidCodeSignature的crash。\n>https://opensource.apple.com/source/dyld/dyld-239.3/src/ImageLoaderMachO.cpp\n>https://opensource.apple.com/source/xnu/xnu-2422.1.72/osfmk/vm/vm_fault.c\n```\nint ImageLoaderMachO::crashIfInvalidCodeSignature()​\n{​\n        // Now that segments are mapped in, try reading from first executable segment.​\n        // If code signing is enabled the kernel will validate the code signature​\n        // when paging in, and kill the process if invalid.​\n        for(unsigned int i=0; i < fSegmentsCount; ++i) {​\n                if ( (segFileOffset(i) == 0) && (segFileSize(i) != 0) ) {​\n                        // return read value to ensure compiler does not optimize away load​\n                        int* p = (int*)segActualLoadAddress(i);​\n                        return \\*p;​\n                }​\n        }​\n        return 0;​\n}\n```\n即使在代码层面想办法绕过这个crash，在提审阶段，也会因为动态库签名问题遭到拒审。\n\n**应该如何引入动态库？**\n苹果提供Embed这种方式来让项目引入动态库，其含义是不链接进项目的可执行文件，但是会被打包进ipa包，这样实际丧失了动态链接本身的空间优化和动态更新的优点。\n![dyld](dyld-14.png)\n但动态链接真的就没有作用了吗？并不是这样。\n随着大型程序的发展，需要链接的库会越来越多，业务研发同学可能会只专注于几个库的开发，此时将会面临代码修改后，编译链接时长增长、lldb调试卡顿等一系列问题，降低研发效能。\n而将业务库作为动态链接库进行开发，编译时不再需要每次都重新构建一整个庞大的主二进制文件，而只需要重新构建各自业务对应的小动态库，研发复杂度大大降低，链接、调试和传输慢等一些列问题也就“迎刃而解”了。\n但是增加动态库也会带来诸多其他问题，比如增加启动耗时。\n业界普遍采用动态库懒加载方案，在程序启动时候默认不加载这些动态库，在启动结束后通过子线程预加载或者进入对应业务场景时候再按需加载对应的动态库。\n总之，动态库的使用需要进行斟酌和取舍，研发效率和使用体验总需要进行平衡，没有银弹。\n\n## 动态链接在Hook中的应用\n接触过Objc开发的同学对fishhook应该都不陌生，Method swizzle只能针对oc方法生效，对于c方法调用，需要使用fishhook，且fishhook只能针对跨模块方法Hook，为什么这样呢？\n```\n/*\n * A structure representing a particular intended rebinding from a symbol\n * name to its replacement\n */\nstruct fbr_rebinding {\n  const char *name;    // 需要hook的方法名称\n  void *replacement;   // 替换方法的地址\n  void **replaced;     // 原始方法的地址\n};\n\n/*\n * For each rebinding in rebindings, rebinds references to external, indirect\n * symbols with the specified name to instead point at replacement for each\n * image in the calling process as well as for all future images that are loaded\n * by the process. If rebind_functions is called more than once, the symbols to\n * rebind are added to the existing list of rebindings, and if a given symbol\n * is rebound more than once, the later rebinding will take precedence.\n */\nFISHHOOK_VISIBILITY\nint fbr_rebind_symbols(struct fbr_rebinding rebindings[], size_t rebindings_nel);\n```\nfishhook实际上就是对动态链接的符号进行hook，之前我们说过，模块间的方法调用需要通过间接跳转，相关跳转方法最终存在DATA段的__got和__la_symbol_ptr中，通过修改这一部分即可达到Hook效果，而模块内的方法调用是固定在TEXT段中的，因此无法进行修改，这也就解释了为什么fishhook只能针对跨模块方法进行Hook。\n\n## Question\n- 动态链接的优点和缺点\n- 地址无关代码、延迟绑定的含义\n- Mach-O动态链接过程\n- iOS开发中使用动态链接库的意义\n- Fishhook原理\n\n## 参考文档\n《程序员的自我修养——链接、装载与库》\nLink fast: Improve build and launch times\nFrameworks: embed or not embed that’s the question\nDynamic Library Programming Topics\niOS15 动态链接 fixup chain 原理详解","source":"_posts/聊聊动态链接.md","raw":"---\ntitle: 聊聊动态链接\ntags:\n  - linker\n  - iOS\ncategories: iOS\ndate: 2023-02-16 21:17:52\n---\n## 前言\n不深入涉及dyld源码的前提下，介绍一下动态链接的概念及原理，在iOS系统上的实现及应用。\n一些需要提前了解的知识点：\n**静态链接**\n- 最初始的应用程序只有一个文件，编译过程就是一个源文件到可执行文件的翻译。\n![static_linker_1](static_linker_1.png)\n- 随着应用程序的复杂度和规模不断增加，程序源码被拆分到多个文件，此时需要对多个目标文件的编译产物进行整合，最终产出一个可执行文件，静态链接器就此出现。\n![static_linker_2](static_linker_2.png)\n- 当一个应用程序的源文件增长到几千上万个时，每次改动后对所有源码进行编译变得非常耗时，此时静态库和ar工具应运而生。\nar工具把多个.o产物打包成一个.a静态库，链接器再将.a静态库和.o文件链接成可执行文件，这样避免了重复编译工作。\n![static_linker_3](static_linker_3.png)\n**ELF文件格式 / Mach-O文件格式 / DEX文件格式**\n- 所有的mach-o文件都包含了一个或多个数据段（Segment），每一个数据段都包含了零个或者多个段落（Section），每个section包含了一些特定类型的代码或者数据，数据段准确的数量以及布局由加载命令和文件类型决定。\n![mach-o](mach-o.png)\n\n## 背景\n静态链接存在的缺点：\n- 内存空间占用大，当多个目标文件需要链接相同的库时，会造成内存资源的浪费\n- 程序兼容性差，当其中一个链接的目标文件更新后，整个程序需要重新编译一遍，无法做到动态更新\n\n## 基本思想\n系统全局仅存在一份动态链接库文件，程序运行时再进行链接。\n![dyld-1](dyld-1.png)\n\n## 原理\n\n### 装载时重定位（Rebasing）\n静态链接通过重定位进行符号寻址，在静态链接器完成空间与地址分配后，便能确定所有目标符号的虚拟地址，对目标文件的外部符号进行重定位修正，这一步可以被称为链接时重定位。\n但是静态链接的重定位方法并不适合动态链接库，动态链接库是在程序运行时才被加载至内存，当程序调用动态链接库文件代码段的绝对地址时，每个程序的重定位偏移量都会不同，没法做到多个程序共享同一份重定位后的动态链接库文件。\n\n**地址无关代码PIC （Position Independent Code）**\n前提：ELF文件格式\n- 一个模块前面是若干页可读代码段，后面是若干页读写数据段\n- 在一个模块内，任何一条指令与其访问的数据之间的相对位置是固定的\n我们期望动态链接库共享的指令在动态库装载时不需要因为装载地址的改变而改变，把那些需要重定位修改的部分抽离出来，与数据段放在一起。\n这样动态链接库指令部分保持不变，被多个程序共享，数据部分则在每个程序进程中存在一份副本。\n- 分类\n  - 模块内部的函数调用\n    - 处于同一个模块，相对地址固定，不需要重定位\n  - 模块内部的数据访问\n    - 指令中不能包含数据的绝对地址，只能进行相对寻址，当前指令加上一个偏移量即可访问\n  - 模块外部的数据访问\n    - 模块外部的数据访问需要等到装载时才能确定，处理思想是把与地址相关的部分放到数据段中\n    - 在数据段中建立全局偏移表GOT（Global Offset Table），代码指令需要访问外部变量时，首先访问GOT中的对应项，在装载时重定位修改GOT的偏移量，找到变量的目标地址\n    - 同模块内部数据访问一样，我们可以知道GOT与代码指令之间的相对位置固定\n  - 模块外部的函数调用\n    - 同样使用GOT，GOT中保存的是目标函数的地址\n- 总结\n\n|  | 指令跳转、调用   | 数据访问 |\n| :--: | :--: | :--: | \n| **模块内部** | 相对跳转和调用 |  相对地址访问  | \n| **模块外部** | 间接跳转和调用（GOT） |  间接访问（GOT）  | \n\n- 还有一个问题\n  - 编译器无法区分一个外部全局变量是否是模块外部调用还是内部调用\n  - 默认按照模块外部全局变量进行调用\n    - 即使用GOT\n\n### 性能损耗\n- 原因\n  - 对于全局和静态的数据访问即模块间的调用都需要进行复杂的GOT定位，间接调用\n  - 动态链接的链接工作是在运行时完成的，即程序开始执行时，动态链接器都要进行一次链接工作\n- 优化\n  - 延迟绑定\n    - 将动态链接从程序启动时进行推迟到当函数第一次被调用时进行\n    - PLT （Procedure Linkage Table）\n- 本质是一个方法跳转\n- 方法重定位后会将地址存入bar@plt\n- bar@plt最开始被初始化为push n，即执行下一条指令\n- _dl_runtime_resolve进行重定位，将方法真正地址写入bar@plt\n![dyld](dyld-2.png)\n\n## iOS动态链接过程\n动态链接所需要的信息记录在这个LC_DYLD_INFO_ONLY这个load command中，包括了Rebase Info、Binding Info、Weak Binding Info、Lazy Binding Info和Export Info五部分内容。\n![dyld](dyld-3.png)\n\n### Rebase\n>Address space layout randomization (ASLR) is a computer security technique involved in preventing exploitation of memory corruption vulnerabilities. In order to prevent an attacker from reliably jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the base of the executable and the positions of the stack, heap and libraries.\n\n地址空间布局随机化（ASLR）是一种计算机安全技术，可防止利用内存进行漏洞攻击。为了防止攻击者可以依靠地址跳转到内存中的某个特定程序段利用功能，ASLR会随机排列进程的关键数据区域的地址，包括可执行文件、堆栈和库的地址。\n对内部指针进行调整，Mach-O文件映射到内存中时，ASLR会进行一个随机偏移，所以需要对内部指针进行调整。\n\n### Bind\n对预留的外部指针进行绑定。\n\n#### Non-lazy binding\n在程序启动时，dyld便通过重定位确定好需动态链接符号的地址。\n在__DATA.__got段中存储所有non-lazy symbol pointers。\n\n#### Lazy binding\n当符号首次被调用时，dyld才进行符号绑定操作。\nDyld Lazy binding过程详解 \n![dyld](dyld-4.png)\n![dyld](dyld-5.png)\n总结一下流程：\n1. 首次调用TEXT.__stub段方法，跳转到对应的DATA.__la_symbol_ptr 方法\n2.  DATA.__la_symbol_ptr 中方法最开始指向到 TEXT.__stub_helper\n3. TEXT.__stub_helper跳转到libdyld.dylib文件__TEXT段的dyld_stub_binder方法\n4. dyld内部调用到_dyld_func_lookup方法动态链接到对应方法，并修改对应的__la_symbol_ptr段\n5. 再次调用，由TEXT.__stub段跳转至DATA.__la_symbol_ptr，直接调用对应方法\n\n#### CHAIEND FIXUPS\n上述Rebase & Bind的过程分析在很多博客中都有过解析，但是我们此时再新建一个工程尝试复刻时，会发现DATA段中的__la_symbol_ptr消失了，这是怎么一回事呢？\n因为目前新建工程时默认的Minimum Deployments为iOS15.0，苹果使用了CHAINED_FIXUPS取代了之前Rebase & Bind机制。苹果在今年的WWDC session中宣称这项优化实际在iOS13.4及之后的版本便已支持。测试来看仅在Minimum Deployments>=15.0时，Mach-O文件格式会发生变化。\n使用CHAINED_FIXUPS的Mach-O会在load command中使用LC_DYLD_CHAINED_FIXUPS和LC_DYLD_EXPORTS_TRIE代替LC_DYLD_INFO_ONLY。\n\n![dyld](dyld-6.png)\n回顾Rebase & Bind过程，不免发现它存在着几个缺点：\n1. Rebase和Bind操作对Mach-O文件进行了两次遍历，可能对某些段进行了重复访问，iOS系统会对较长时间没有用到的page进行压缩处理，两遍遍历导致了额外的page压缩与解压缩操作，增加耗时的同时没有利用到空间局部性；\n2. 用于存放Rebase和Bind信息的LINKEDIT段在动态链接完成后失去了作用，但仍占用了Mach-O文件的体积，如果能对这部分空间重复利用的话可以减少包体积。\n   \nChained Fixups实际上采用链表的方式来将rebase和bind的信息整合到一起，需要进行Rebase/Bind的符号不再被记录到__LINKEDIT中，而是以链表的形式记录到__DATA 段中，__LINKEDIT段仅记录需要修复的segment表头。\n![dyld](dyld-7.png)\n![dyld](dyld-8.png)\n>不使用Chained Fixups：\n![dyld](dyld-9.png)\n![dyld](dyld-10.png)\n使用Chined Fixups：\n![dyld](dyld-11.png)\n\n对比可以发现，使用Chained Fixups的Mach-O文件DATA段不再保存__la_symbol_ptr，全部使用__got段存储需动态链接的符号，且不再使用空指针占位，而是保存了链表信息，实际是存放了64位大小的 ChainedFixupPointerOnDisk union（可以是 dyld_chained_ptr_64_rebase，dyld_chained_ptr_64_bind，或者其它类型的fixup chain节点），而 dyld 则会利用这部分信息进行 rebase&bind。 \n总体来说，Chained fixup方案中，dyld不需要再去一边读取LINKEDIT段信息一遍做rebase&bind操作，而是直接沿着链表逐个读取节点，这样dyld即可在一次遍历中完成rebase及bind操作，减少了不必要的page压缩及解压缩操作，利用了空间局限性，减少了耗时。\n\n#### Page-in Linking\n今年的WWDC，苹果又公布了dyld的一项新功能，Page-in Linking。和过去 dyld 在启动时一次性统一修正所有的动态链接库符号不同，dyld现在可以在 page-in 的时候去自动修正 DATA 段内的 page。一直以来，内核都可以通过 mmap() 来访问 page，但是现在，如果它是一个 DATA page，内核在访问的同时还会顺便对其进行 fixup，这种机制减少了脏内存和启动时间，这也意味着 DATA_CONST 段的page是干净的，它们可以像 TEXT 页面一样被暂时移出内存和重新创建，从而减少内存压力。但 page-in linking 只适用于用 chained fixups 构建的二进制文件。这是因为在 chained fixups 中，大部分修复信息将被编码在磁盘上的 DATA 段中，这意味着在 page-in 时内核可以使用这些信息。\n有一点需要注意的是，dyld 只会在应用启动时使用这一机制。任何后来被 dlopen() 打开的 dylibs 都不会进行 page-in linking。在这种情况下，dyld 会采用传统的方法，在调用 dlopen 时应用 fixup。\n![dyld](dyld-12.png)\n\n## 动态链接在APP中的应用\niOS系统层面实际上运用了大量的动态链接库，可以在App的Mach-O文件的Load Commands中查看所有LC_LOAD_DYLIB动态库。\n![dyld](dyld-13.png)\n但是对于APP来说，只能引入App内签名的动态库和系统签名的动态库，并不能如愿的引入第三方发布的动态链接库，原因在于dyld内部禁止加载非App签名的image文件，尝试加载会触发crashIfInvalidCodeSignature的crash。\n>https://opensource.apple.com/source/dyld/dyld-239.3/src/ImageLoaderMachO.cpp\n>https://opensource.apple.com/source/xnu/xnu-2422.1.72/osfmk/vm/vm_fault.c\n```\nint ImageLoaderMachO::crashIfInvalidCodeSignature()​\n{​\n        // Now that segments are mapped in, try reading from first executable segment.​\n        // If code signing is enabled the kernel will validate the code signature​\n        // when paging in, and kill the process if invalid.​\n        for(unsigned int i=0; i < fSegmentsCount; ++i) {​\n                if ( (segFileOffset(i) == 0) && (segFileSize(i) != 0) ) {​\n                        // return read value to ensure compiler does not optimize away load​\n                        int* p = (int*)segActualLoadAddress(i);​\n                        return \\*p;​\n                }​\n        }​\n        return 0;​\n}\n```\n即使在代码层面想办法绕过这个crash，在提审阶段，也会因为动态库签名问题遭到拒审。\n\n**应该如何引入动态库？**\n苹果提供Embed这种方式来让项目引入动态库，其含义是不链接进项目的可执行文件，但是会被打包进ipa包，这样实际丧失了动态链接本身的空间优化和动态更新的优点。\n![dyld](dyld-14.png)\n但动态链接真的就没有作用了吗？并不是这样。\n随着大型程序的发展，需要链接的库会越来越多，业务研发同学可能会只专注于几个库的开发，此时将会面临代码修改后，编译链接时长增长、lldb调试卡顿等一系列问题，降低研发效能。\n而将业务库作为动态链接库进行开发，编译时不再需要每次都重新构建一整个庞大的主二进制文件，而只需要重新构建各自业务对应的小动态库，研发复杂度大大降低，链接、调试和传输慢等一些列问题也就“迎刃而解”了。\n但是增加动态库也会带来诸多其他问题，比如增加启动耗时。\n业界普遍采用动态库懒加载方案，在程序启动时候默认不加载这些动态库，在启动结束后通过子线程预加载或者进入对应业务场景时候再按需加载对应的动态库。\n总之，动态库的使用需要进行斟酌和取舍，研发效率和使用体验总需要进行平衡，没有银弹。\n\n## 动态链接在Hook中的应用\n接触过Objc开发的同学对fishhook应该都不陌生，Method swizzle只能针对oc方法生效，对于c方法调用，需要使用fishhook，且fishhook只能针对跨模块方法Hook，为什么这样呢？\n```\n/*\n * A structure representing a particular intended rebinding from a symbol\n * name to its replacement\n */\nstruct fbr_rebinding {\n  const char *name;    // 需要hook的方法名称\n  void *replacement;   // 替换方法的地址\n  void **replaced;     // 原始方法的地址\n};\n\n/*\n * For each rebinding in rebindings, rebinds references to external, indirect\n * symbols with the specified name to instead point at replacement for each\n * image in the calling process as well as for all future images that are loaded\n * by the process. If rebind_functions is called more than once, the symbols to\n * rebind are added to the existing list of rebindings, and if a given symbol\n * is rebound more than once, the later rebinding will take precedence.\n */\nFISHHOOK_VISIBILITY\nint fbr_rebind_symbols(struct fbr_rebinding rebindings[], size_t rebindings_nel);\n```\nfishhook实际上就是对动态链接的符号进行hook，之前我们说过，模块间的方法调用需要通过间接跳转，相关跳转方法最终存在DATA段的__got和__la_symbol_ptr中，通过修改这一部分即可达到Hook效果，而模块内的方法调用是固定在TEXT段中的，因此无法进行修改，这也就解释了为什么fishhook只能针对跨模块方法进行Hook。\n\n## Question\n- 动态链接的优点和缺点\n- 地址无关代码、延迟绑定的含义\n- Mach-O动态链接过程\n- iOS开发中使用动态链接库的意义\n- Fishhook原理\n\n## 参考文档\n《程序员的自我修养——链接、装载与库》\nLink fast: Improve build and launch times\nFrameworks: embed or not embed that’s the question\nDynamic Library Programming Topics\niOS15 动态链接 fixup chain 原理详解","slug":"聊聊动态链接","published":1,"updated":"2023-02-20T07:05:33.401Z","_id":"clecf0tyv0000gylg29yt32e7","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>不深入涉及dyld源码的前提下，介绍一下动态链接的概念及原理，在iOS系统上的实现及应用。<br>一些需要提前了解的知识点：<br><strong>静态链接</strong></p>\n<ul>\n<li>最初始的应用程序只有一个文件，编译过程就是一个源文件到可执行文件的翻译。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/static_linker_1.png\" alt=\"static_linker_1\"></li>\n<li>随着应用程序的复杂度和规模不断增加，程序源码被拆分到多个文件，此时需要对多个目标文件的编译产物进行整合，最终产出一个可执行文件，静态链接器就此出现。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/static_linker_2.png\" alt=\"static_linker_2\"></li>\n<li>当一个应用程序的源文件增长到几千上万个时，每次改动后对所有源码进行编译变得非常耗时，此时静态库和ar工具应运而生。<br>ar工具把多个.o产物打包成一个.a静态库，链接器再将.a静态库和.o文件链接成可执行文件，这样避免了重复编译工作。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/static_linker_3.png\" alt=\"static_linker_3\"></li>\n</ul>\n<p><strong>ELF文件格式 / Mach-O文件格式 / DEX文件格式</strong></p>\n<ul>\n<li>所有的mach-o文件都包含了一个或多个数据段（Segment），每一个数据段都包含了零个或者多个段落（Section），每个section包含了一些特定类型的代码或者数据，数据段准确的数量以及布局由加载命令和文件类型决定。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/mach-o.png\" alt=\"mach-o\"></li>\n</ul>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>静态链接存在的缺点：</p>\n<ul>\n<li>内存空间占用大，当多个目标文件需要链接相同的库时，会造成内存资源的浪费</li>\n<li>程序兼容性差，当其中一个链接的目标文件更新后，整个程序需要重新编译一遍，无法做到动态更新</li>\n</ul>\n<h2 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h2><p>系统全局仅存在一份动态链接库文件，程序运行时再进行链接。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-1.png\" alt=\"dyld-1\"></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"装载时重定位（Rebasing）\"><a href=\"#装载时重定位（Rebasing）\" class=\"headerlink\" title=\"装载时重定位（Rebasing）\"></a>装载时重定位（Rebasing）</h3><p>静态链接通过重定位进行符号寻址，在静态链接器完成空间与地址分配后，便能确定所有目标符号的虚拟地址，对目标文件的外部符号进行重定位修正，这一步可以被称为链接时重定位。<br>但是静态链接的重定位方法并不适合动态链接库，动态链接库是在程序运行时才被加载至内存，当程序调用动态链接库文件代码段的绝对地址时，每个程序的重定位偏移量都会不同，没法做到多个程序共享同一份重定位后的动态链接库文件。</p>\n<p><strong>地址无关代码PIC （Position Independent Code）</strong><br>前提：ELF文件格式</p>\n<ul>\n<li>一个模块前面是若干页可读代码段，后面是若干页读写数据段</li>\n<li>在一个模块内，任何一条指令与其访问的数据之间的相对位置是固定的<br>我们期望动态链接库共享的指令在动态库装载时不需要因为装载地址的改变而改变，把那些需要重定位修改的部分抽离出来，与数据段放在一起。<br>这样动态链接库指令部分保持不变，被多个程序共享，数据部分则在每个程序进程中存在一份副本。</li>\n<li>分类<ul>\n<li>模块内部的函数调用<ul>\n<li>处于同一个模块，相对地址固定，不需要重定位</li>\n</ul>\n</li>\n<li>模块内部的数据访问<ul>\n<li>指令中不能包含数据的绝对地址，只能进行相对寻址，当前指令加上一个偏移量即可访问</li>\n</ul>\n</li>\n<li>模块外部的数据访问<ul>\n<li>模块外部的数据访问需要等到装载时才能确定，处理思想是把与地址相关的部分放到数据段中</li>\n<li>在数据段中建立全局偏移表GOT（Global Offset Table），代码指令需要访问外部变量时，首先访问GOT中的对应项，在装载时重定位修改GOT的偏移量，找到变量的目标地址</li>\n<li>同模块内部数据访问一样，我们可以知道GOT与代码指令之间的相对位置固定</li>\n</ul>\n</li>\n<li>模块外部的函数调用<ul>\n<li>同样使用GOT，GOT中保存的是目标函数的地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总结</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">指令跳转、调用</th>\n<th align=\"center\">数据访问</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>模块内部</strong></td>\n<td align=\"center\">相对跳转和调用</td>\n<td align=\"center\">相对地址访问</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>模块外部</strong></td>\n<td align=\"center\">间接跳转和调用（GOT）</td>\n<td align=\"center\">间接访问（GOT）</td>\n</tr>\n</tbody></table>\n<ul>\n<li>还有一个问题<ul>\n<li>编译器无法区分一个外部全局变量是否是模块外部调用还是内部调用</li>\n<li>默认按照模块外部全局变量进行调用<ul>\n<li>即使用GOT</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"性能损耗\"><a href=\"#性能损耗\" class=\"headerlink\" title=\"性能损耗\"></a>性能损耗</h3><ul>\n<li>原因<ul>\n<li>对于全局和静态的数据访问即模块间的调用都需要进行复杂的GOT定位，间接调用</li>\n<li>动态链接的链接工作是在运行时完成的，即程序开始执行时，动态链接器都要进行一次链接工作</li>\n</ul>\n</li>\n<li>优化<ul>\n<li>延迟绑定<ul>\n<li>将动态链接从程序启动时进行推迟到当函数第一次被调用时进行</li>\n<li>PLT （Procedure Linkage Table）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>本质是一个方法跳转</li>\n<li>方法重定位后会将地址存入bar@plt</li>\n<li>bar@plt最开始被初始化为push n，即执行下一条指令</li>\n<li>_dl_runtime_resolve进行重定位，将方法真正地址写入bar@plt<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-2.png\" alt=\"dyld\"></li>\n</ul>\n<h2 id=\"iOS动态链接过程\"><a href=\"#iOS动态链接过程\" class=\"headerlink\" title=\"iOS动态链接过程\"></a>iOS动态链接过程</h2><p>动态链接所需要的信息记录在这个LC_DYLD_INFO_ONLY这个load command中，包括了Rebase Info、Binding Info、Weak Binding Info、Lazy Binding Info和Export Info五部分内容。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-3.png\" alt=\"dyld\"></p>\n<h3 id=\"Rebase\"><a href=\"#Rebase\" class=\"headerlink\" title=\"Rebase\"></a>Rebase</h3><blockquote>\n<p>Address space layout randomization (ASLR) is a computer security technique involved in preventing exploitation of memory corruption vulnerabilities. In order to prevent an attacker from reliably jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the base of the executable and the positions of the stack, heap and libraries.</p>\n</blockquote>\n<p>地址空间布局随机化（ASLR）是一种计算机安全技术，可防止利用内存进行漏洞攻击。为了防止攻击者可以依靠地址跳转到内存中的某个特定程序段利用功能，ASLR会随机排列进程的关键数据区域的地址，包括可执行文件、堆栈和库的地址。<br>对内部指针进行调整，Mach-O文件映射到内存中时，ASLR会进行一个随机偏移，所以需要对内部指针进行调整。</p>\n<h3 id=\"Bind\"><a href=\"#Bind\" class=\"headerlink\" title=\"Bind\"></a>Bind</h3><p>对预留的外部指针进行绑定。</p>\n<h4 id=\"Non-lazy-binding\"><a href=\"#Non-lazy-binding\" class=\"headerlink\" title=\"Non-lazy binding\"></a>Non-lazy binding</h4><p>在程序启动时，dyld便通过重定位确定好需动态链接符号的地址。<br>在__DATA.__got段中存储所有non-lazy symbol pointers。</p>\n<h4 id=\"Lazy-binding\"><a href=\"#Lazy-binding\" class=\"headerlink\" title=\"Lazy binding\"></a>Lazy binding</h4><p>当符号首次被调用时，dyld才进行符号绑定操作。<br>Dyld Lazy binding过程详解<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-4.png\" alt=\"dyld\"><br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-5.png\" alt=\"dyld\"><br>总结一下流程：</p>\n<ol>\n<li>首次调用TEXT.__stub段方法，跳转到对应的DATA.__la_symbol_ptr 方法</li>\n<li>DATA.__la_symbol_ptr 中方法最开始指向到 TEXT.__stub_helper</li>\n<li>TEXT.__stub_helper跳转到libdyld.dylib文件__TEXT段的dyld_stub_binder方法</li>\n<li>dyld内部调用到_dyld_func_lookup方法动态链接到对应方法，并修改对应的__la_symbol_ptr段</li>\n<li>再次调用，由TEXT.__stub段跳转至DATA.__la_symbol_ptr，直接调用对应方法</li>\n</ol>\n<h4 id=\"CHAIEND-FIXUPS\"><a href=\"#CHAIEND-FIXUPS\" class=\"headerlink\" title=\"CHAIEND FIXUPS\"></a>CHAIEND FIXUPS</h4><p>上述Rebase &amp; Bind的过程分析在很多博客中都有过解析，但是我们此时再新建一个工程尝试复刻时，会发现DATA段中的__la_symbol_ptr消失了，这是怎么一回事呢？<br>因为目前新建工程时默认的Minimum Deployments为iOS15.0，苹果使用了CHAINED_FIXUPS取代了之前Rebase &amp; Bind机制。苹果在今年的WWDC session中宣称这项优化实际在iOS13.4及之后的版本便已支持。测试来看仅在Minimum Deployments&gt;=15.0时，Mach-O文件格式会发生变化。<br>使用CHAINED_FIXUPS的Mach-O会在load command中使用LC_DYLD_CHAINED_FIXUPS和LC_DYLD_EXPORTS_TRIE代替LC_DYLD_INFO_ONLY。</p>\n<p><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-6.png\" alt=\"dyld\"><br>回顾Rebase &amp; Bind过程，不免发现它存在着几个缺点：</p>\n<ol>\n<li>Rebase和Bind操作对Mach-O文件进行了两次遍历，可能对某些段进行了重复访问，iOS系统会对较长时间没有用到的page进行压缩处理，两遍遍历导致了额外的page压缩与解压缩操作，增加耗时的同时没有利用到空间局部性；</li>\n<li>用于存放Rebase和Bind信息的LINKEDIT段在动态链接完成后失去了作用，但仍占用了Mach-O文件的体积，如果能对这部分空间重复利用的话可以减少包体积。</li>\n</ol>\n<p>Chained Fixups实际上采用链表的方式来将rebase和bind的信息整合到一起，需要进行Rebase/Bind的符号不再被记录到__LINKEDIT中，而是以链表的形式记录到__DATA 段中，__LINKEDIT段仅记录需要修复的segment表头。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-7.png\" alt=\"dyld\"><br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-8.png\" alt=\"dyld\"></p>\n<blockquote>\n<p>不使用Chained Fixups：<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-9.png\" alt=\"dyld\"><br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-10.png\" alt=\"dyld\"><br>使用Chined Fixups：<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-11.png\" alt=\"dyld\"></p>\n</blockquote>\n<p>对比可以发现，使用Chained Fixups的Mach-O文件DATA段不再保存__la_symbol_ptr，全部使用__got段存储需动态链接的符号，且不再使用空指针占位，而是保存了链表信息，实际是存放了64位大小的 ChainedFixupPointerOnDisk union（可以是 dyld_chained_ptr_64_rebase，dyld_chained_ptr_64_bind，或者其它类型的fixup chain节点），而 dyld 则会利用这部分信息进行 rebase&amp;bind。<br>总体来说，Chained fixup方案中，dyld不需要再去一边读取LINKEDIT段信息一遍做rebase&amp;bind操作，而是直接沿着链表逐个读取节点，这样dyld即可在一次遍历中完成rebase及bind操作，减少了不必要的page压缩及解压缩操作，利用了空间局限性，减少了耗时。</p>\n<h4 id=\"Page-in-Linking\"><a href=\"#Page-in-Linking\" class=\"headerlink\" title=\"Page-in Linking\"></a>Page-in Linking</h4><p>今年的WWDC，苹果又公布了dyld的一项新功能，Page-in Linking。和过去 dyld 在启动时一次性统一修正所有的动态链接库符号不同，dyld现在可以在 page-in 的时候去自动修正 DATA 段内的 page。一直以来，内核都可以通过 mmap() 来访问 page，但是现在，如果它是一个 DATA page，内核在访问的同时还会顺便对其进行 fixup，这种机制减少了脏内存和启动时间，这也意味着 DATA_CONST 段的page是干净的，它们可以像 TEXT 页面一样被暂时移出内存和重新创建，从而减少内存压力。但 page-in linking 只适用于用 chained fixups 构建的二进制文件。这是因为在 chained fixups 中，大部分修复信息将被编码在磁盘上的 DATA 段中，这意味着在 page-in 时内核可以使用这些信息。<br>有一点需要注意的是，dyld 只会在应用启动时使用这一机制。任何后来被 dlopen() 打开的 dylibs 都不会进行 page-in linking。在这种情况下，dyld 会采用传统的方法，在调用 dlopen 时应用 fixup。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-12.png\" alt=\"dyld\"></p>\n<h2 id=\"动态链接在APP中的应用\"><a href=\"#动态链接在APP中的应用\" class=\"headerlink\" title=\"动态链接在APP中的应用\"></a>动态链接在APP中的应用</h2><p>iOS系统层面实际上运用了大量的动态链接库，可以在App的Mach-O文件的Load Commands中查看所有LC_LOAD_DYLIB动态库。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-13.png\" alt=\"dyld\"><br>但是对于APP来说，只能引入App内签名的动态库和系统签名的动态库，并不能如愿的引入第三方发布的动态链接库，原因在于dyld内部禁止加载非App签名的image文件，尝试加载会触发crashIfInvalidCodeSignature的crash。</p>\n<blockquote>\n<p><a href=\"https://opensource.apple.com/source/dyld/dyld-239.3/src/ImageLoaderMachO.cpp\">https://opensource.apple.com/source/dyld/dyld-239.3/src/ImageLoaderMachO.cpp</a><br><a href=\"https://opensource.apple.com/source/xnu/xnu-2422.1.72/osfmk/vm/vm_fault.c\">https://opensource.apple.com/source/xnu/xnu-2422.1.72/osfmk/vm/vm_fault.c</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ImageLoaderMachO::crashIfInvalidCodeSignature()​</span><br><span class=\"line\">&#123;​</span><br><span class=\"line\">        &#x2F;&#x2F; Now that segments are mapped in, try reading from first executable segment.​</span><br><span class=\"line\">        &#x2F;&#x2F; If code signing is enabled the kernel will validate the code signature​</span><br><span class=\"line\">        &#x2F;&#x2F; when paging in, and kill the process if invalid.​</span><br><span class=\"line\">        for(unsigned int i&#x3D;0; i &lt; fSegmentsCount; ++i) &#123;​</span><br><span class=\"line\">                if ( (segFileOffset(i) &#x3D;&#x3D; 0) &amp;&amp; (segFileSize(i) !&#x3D; 0) ) &#123;​</span><br><span class=\"line\">                        &#x2F;&#x2F; return read value to ensure compiler does not optimize away load​</span><br><span class=\"line\">                        int* p &#x3D; (int*)segActualLoadAddress(i);​</span><br><span class=\"line\">                        return \\*p;​</span><br><span class=\"line\">                &#125;​</span><br><span class=\"line\">        &#125;​</span><br><span class=\"line\">        return 0;​</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>即使在代码层面想办法绕过这个crash，在提审阶段，也会因为动态库签名问题遭到拒审。</p>\n<p><strong>应该如何引入动态库？</strong><br>苹果提供Embed这种方式来让项目引入动态库，其含义是不链接进项目的可执行文件，但是会被打包进ipa包，这样实际丧失了动态链接本身的空间优化和动态更新的优点。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-14.png\" alt=\"dyld\"><br>但动态链接真的就没有作用了吗？并不是这样。<br>随着大型程序的发展，需要链接的库会越来越多，业务研发同学可能会只专注于几个库的开发，此时将会面临代码修改后，编译链接时长增长、lldb调试卡顿等一系列问题，降低研发效能。<br>而将业务库作为动态链接库进行开发，编译时不再需要每次都重新构建一整个庞大的主二进制文件，而只需要重新构建各自业务对应的小动态库，研发复杂度大大降低，链接、调试和传输慢等一些列问题也就“迎刃而解”了。<br>但是增加动态库也会带来诸多其他问题，比如增加启动耗时。<br>业界普遍采用动态库懒加载方案，在程序启动时候默认不加载这些动态库，在启动结束后通过子线程预加载或者进入对应业务场景时候再按需加载对应的动态库。<br>总之，动态库的使用需要进行斟酌和取舍，研发效率和使用体验总需要进行平衡，没有银弹。</p>\n<h2 id=\"动态链接在Hook中的应用\"><a href=\"#动态链接在Hook中的应用\" class=\"headerlink\" title=\"动态链接在Hook中的应用\"></a>动态链接在Hook中的应用</h2><p>接触过Objc开发的同学对fishhook应该都不陌生，Method swizzle只能针对oc方法生效，对于c方法调用，需要使用fishhook，且fishhook只能针对跨模块方法Hook，为什么这样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * A structure representing a particular intended rebinding from a symbol</span><br><span class=\"line\"> * name to its replacement</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">struct fbr_rebinding &#123;</span><br><span class=\"line\">  const char *name;    &#x2F;&#x2F; 需要hook的方法名称</span><br><span class=\"line\">  void *replacement;   &#x2F;&#x2F; 替换方法的地址</span><br><span class=\"line\">  void **replaced;     &#x2F;&#x2F; 原始方法的地址</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * For each rebinding in rebindings, rebinds references to external, indirect</span><br><span class=\"line\"> * symbols with the specified name to instead point at replacement for each</span><br><span class=\"line\"> * image in the calling process as well as for all future images that are loaded</span><br><span class=\"line\"> * by the process. If rebind_functions is called more than once, the symbols to</span><br><span class=\"line\"> * rebind are added to the existing list of rebindings, and if a given symbol</span><br><span class=\"line\"> * is rebound more than once, the later rebinding will take precedence.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">FISHHOOK_VISIBILITY</span><br><span class=\"line\">int fbr_rebind_symbols(struct fbr_rebinding rebindings[], size_t rebindings_nel);</span><br></pre></td></tr></table></figure>\n<p>fishhook实际上就是对动态链接的符号进行hook，之前我们说过，模块间的方法调用需要通过间接跳转，相关跳转方法最终存在DATA段的__got和__la_symbol_ptr中，通过修改这一部分即可达到Hook效果，而模块内的方法调用是固定在TEXT段中的，因此无法进行修改，这也就解释了为什么fishhook只能针对跨模块方法进行Hook。</p>\n<h2 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>动态链接的优点和缺点</li>\n<li>地址无关代码、延迟绑定的含义</li>\n<li>Mach-O动态链接过程</li>\n<li>iOS开发中使用动态链接库的意义</li>\n<li>Fishhook原理</li>\n</ul>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p>《程序员的自我修养——链接、装载与库》<br>Link fast: Improve build and launch times<br>Frameworks: embed or not embed that’s the question<br>Dynamic Library Programming Topics<br>iOS15 动态链接 fixup chain 原理详解</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>不深入涉及dyld源码的前提下，介绍一下动态链接的概念及原理，在iOS系统上的实现及应用。<br>一些需要提前了解的知识点：<br><strong>静态链接</strong></p>\n<ul>\n<li>最初始的应用程序只有一个文件，编译过程就是一个源文件到可执行文件的翻译。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/static_linker_1.png\" alt=\"static_linker_1\"></li>\n<li>随着应用程序的复杂度和规模不断增加，程序源码被拆分到多个文件，此时需要对多个目标文件的编译产物进行整合，最终产出一个可执行文件，静态链接器就此出现。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/static_linker_2.png\" alt=\"static_linker_2\"></li>\n<li>当一个应用程序的源文件增长到几千上万个时，每次改动后对所有源码进行编译变得非常耗时，此时静态库和ar工具应运而生。<br>ar工具把多个.o产物打包成一个.a静态库，链接器再将.a静态库和.o文件链接成可执行文件，这样避免了重复编译工作。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/static_linker_3.png\" alt=\"static_linker_3\"></li>\n</ul>\n<p><strong>ELF文件格式 / Mach-O文件格式 / DEX文件格式</strong></p>\n<ul>\n<li>所有的mach-o文件都包含了一个或多个数据段（Segment），每一个数据段都包含了零个或者多个段落（Section），每个section包含了一些特定类型的代码或者数据，数据段准确的数量以及布局由加载命令和文件类型决定。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/mach-o.png\" alt=\"mach-o\"></li>\n</ul>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>静态链接存在的缺点：</p>\n<ul>\n<li>内存空间占用大，当多个目标文件需要链接相同的库时，会造成内存资源的浪费</li>\n<li>程序兼容性差，当其中一个链接的目标文件更新后，整个程序需要重新编译一遍，无法做到动态更新</li>\n</ul>\n<h2 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h2><p>系统全局仅存在一份动态链接库文件，程序运行时再进行链接。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-1.png\" alt=\"dyld-1\"></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"装载时重定位（Rebasing）\"><a href=\"#装载时重定位（Rebasing）\" class=\"headerlink\" title=\"装载时重定位（Rebasing）\"></a>装载时重定位（Rebasing）</h3><p>静态链接通过重定位进行符号寻址，在静态链接器完成空间与地址分配后，便能确定所有目标符号的虚拟地址，对目标文件的外部符号进行重定位修正，这一步可以被称为链接时重定位。<br>但是静态链接的重定位方法并不适合动态链接库，动态链接库是在程序运行时才被加载至内存，当程序调用动态链接库文件代码段的绝对地址时，每个程序的重定位偏移量都会不同，没法做到多个程序共享同一份重定位后的动态链接库文件。</p>\n<p><strong>地址无关代码PIC （Position Independent Code）</strong><br>前提：ELF文件格式</p>\n<ul>\n<li>一个模块前面是若干页可读代码段，后面是若干页读写数据段</li>\n<li>在一个模块内，任何一条指令与其访问的数据之间的相对位置是固定的<br>我们期望动态链接库共享的指令在动态库装载时不需要因为装载地址的改变而改变，把那些需要重定位修改的部分抽离出来，与数据段放在一起。<br>这样动态链接库指令部分保持不变，被多个程序共享，数据部分则在每个程序进程中存在一份副本。</li>\n<li>分类<ul>\n<li>模块内部的函数调用<ul>\n<li>处于同一个模块，相对地址固定，不需要重定位</li>\n</ul>\n</li>\n<li>模块内部的数据访问<ul>\n<li>指令中不能包含数据的绝对地址，只能进行相对寻址，当前指令加上一个偏移量即可访问</li>\n</ul>\n</li>\n<li>模块外部的数据访问<ul>\n<li>模块外部的数据访问需要等到装载时才能确定，处理思想是把与地址相关的部分放到数据段中</li>\n<li>在数据段中建立全局偏移表GOT（Global Offset Table），代码指令需要访问外部变量时，首先访问GOT中的对应项，在装载时重定位修改GOT的偏移量，找到变量的目标地址</li>\n<li>同模块内部数据访问一样，我们可以知道GOT与代码指令之间的相对位置固定</li>\n</ul>\n</li>\n<li>模块外部的函数调用<ul>\n<li>同样使用GOT，GOT中保存的是目标函数的地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总结</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">指令跳转、调用</th>\n<th align=\"center\">数据访问</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>模块内部</strong></td>\n<td align=\"center\">相对跳转和调用</td>\n<td align=\"center\">相对地址访问</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>模块外部</strong></td>\n<td align=\"center\">间接跳转和调用（GOT）</td>\n<td align=\"center\">间接访问（GOT）</td>\n</tr>\n</tbody></table>\n<ul>\n<li>还有一个问题<ul>\n<li>编译器无法区分一个外部全局变量是否是模块外部调用还是内部调用</li>\n<li>默认按照模块外部全局变量进行调用<ul>\n<li>即使用GOT</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"性能损耗\"><a href=\"#性能损耗\" class=\"headerlink\" title=\"性能损耗\"></a>性能损耗</h3><ul>\n<li>原因<ul>\n<li>对于全局和静态的数据访问即模块间的调用都需要进行复杂的GOT定位，间接调用</li>\n<li>动态链接的链接工作是在运行时完成的，即程序开始执行时，动态链接器都要进行一次链接工作</li>\n</ul>\n</li>\n<li>优化<ul>\n<li>延迟绑定<ul>\n<li>将动态链接从程序启动时进行推迟到当函数第一次被调用时进行</li>\n<li>PLT （Procedure Linkage Table）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>本质是一个方法跳转</li>\n<li>方法重定位后会将地址存入bar@plt</li>\n<li>bar@plt最开始被初始化为push n，即执行下一条指令</li>\n<li>_dl_runtime_resolve进行重定位，将方法真正地址写入bar@plt<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-2.png\" alt=\"dyld\"></li>\n</ul>\n<h2 id=\"iOS动态链接过程\"><a href=\"#iOS动态链接过程\" class=\"headerlink\" title=\"iOS动态链接过程\"></a>iOS动态链接过程</h2><p>动态链接所需要的信息记录在这个LC_DYLD_INFO_ONLY这个load command中，包括了Rebase Info、Binding Info、Weak Binding Info、Lazy Binding Info和Export Info五部分内容。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-3.png\" alt=\"dyld\"></p>\n<h3 id=\"Rebase\"><a href=\"#Rebase\" class=\"headerlink\" title=\"Rebase\"></a>Rebase</h3><blockquote>\n<p>Address space layout randomization (ASLR) is a computer security technique involved in preventing exploitation of memory corruption vulnerabilities. In order to prevent an attacker from reliably jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the base of the executable and the positions of the stack, heap and libraries.</p>\n</blockquote>\n<p>地址空间布局随机化（ASLR）是一种计算机安全技术，可防止利用内存进行漏洞攻击。为了防止攻击者可以依靠地址跳转到内存中的某个特定程序段利用功能，ASLR会随机排列进程的关键数据区域的地址，包括可执行文件、堆栈和库的地址。<br>对内部指针进行调整，Mach-O文件映射到内存中时，ASLR会进行一个随机偏移，所以需要对内部指针进行调整。</p>\n<h3 id=\"Bind\"><a href=\"#Bind\" class=\"headerlink\" title=\"Bind\"></a>Bind</h3><p>对预留的外部指针进行绑定。</p>\n<h4 id=\"Non-lazy-binding\"><a href=\"#Non-lazy-binding\" class=\"headerlink\" title=\"Non-lazy binding\"></a>Non-lazy binding</h4><p>在程序启动时，dyld便通过重定位确定好需动态链接符号的地址。<br>在__DATA.__got段中存储所有non-lazy symbol pointers。</p>\n<h4 id=\"Lazy-binding\"><a href=\"#Lazy-binding\" class=\"headerlink\" title=\"Lazy binding\"></a>Lazy binding</h4><p>当符号首次被调用时，dyld才进行符号绑定操作。<br>Dyld Lazy binding过程详解<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-4.png\" alt=\"dyld\"><br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-5.png\" alt=\"dyld\"><br>总结一下流程：</p>\n<ol>\n<li>首次调用TEXT.__stub段方法，跳转到对应的DATA.__la_symbol_ptr 方法</li>\n<li>DATA.__la_symbol_ptr 中方法最开始指向到 TEXT.__stub_helper</li>\n<li>TEXT.__stub_helper跳转到libdyld.dylib文件__TEXT段的dyld_stub_binder方法</li>\n<li>dyld内部调用到_dyld_func_lookup方法动态链接到对应方法，并修改对应的__la_symbol_ptr段</li>\n<li>再次调用，由TEXT.__stub段跳转至DATA.__la_symbol_ptr，直接调用对应方法</li>\n</ol>\n<h4 id=\"CHAIEND-FIXUPS\"><a href=\"#CHAIEND-FIXUPS\" class=\"headerlink\" title=\"CHAIEND FIXUPS\"></a>CHAIEND FIXUPS</h4><p>上述Rebase &amp; Bind的过程分析在很多博客中都有过解析，但是我们此时再新建一个工程尝试复刻时，会发现DATA段中的__la_symbol_ptr消失了，这是怎么一回事呢？<br>因为目前新建工程时默认的Minimum Deployments为iOS15.0，苹果使用了CHAINED_FIXUPS取代了之前Rebase &amp; Bind机制。苹果在今年的WWDC session中宣称这项优化实际在iOS13.4及之后的版本便已支持。测试来看仅在Minimum Deployments&gt;=15.0时，Mach-O文件格式会发生变化。<br>使用CHAINED_FIXUPS的Mach-O会在load command中使用LC_DYLD_CHAINED_FIXUPS和LC_DYLD_EXPORTS_TRIE代替LC_DYLD_INFO_ONLY。</p>\n<p><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-6.png\" alt=\"dyld\"><br>回顾Rebase &amp; Bind过程，不免发现它存在着几个缺点：</p>\n<ol>\n<li>Rebase和Bind操作对Mach-O文件进行了两次遍历，可能对某些段进行了重复访问，iOS系统会对较长时间没有用到的page进行压缩处理，两遍遍历导致了额外的page压缩与解压缩操作，增加耗时的同时没有利用到空间局部性；</li>\n<li>用于存放Rebase和Bind信息的LINKEDIT段在动态链接完成后失去了作用，但仍占用了Mach-O文件的体积，如果能对这部分空间重复利用的话可以减少包体积。</li>\n</ol>\n<p>Chained Fixups实际上采用链表的方式来将rebase和bind的信息整合到一起，需要进行Rebase/Bind的符号不再被记录到__LINKEDIT中，而是以链表的形式记录到__DATA 段中，__LINKEDIT段仅记录需要修复的segment表头。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-7.png\" alt=\"dyld\"><br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-8.png\" alt=\"dyld\"></p>\n<blockquote>\n<p>不使用Chained Fixups：<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-9.png\" alt=\"dyld\"><br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-10.png\" alt=\"dyld\"><br>使用Chined Fixups：<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-11.png\" alt=\"dyld\"></p>\n</blockquote>\n<p>对比可以发现，使用Chained Fixups的Mach-O文件DATA段不再保存__la_symbol_ptr，全部使用__got段存储需动态链接的符号，且不再使用空指针占位，而是保存了链表信息，实际是存放了64位大小的 ChainedFixupPointerOnDisk union（可以是 dyld_chained_ptr_64_rebase，dyld_chained_ptr_64_bind，或者其它类型的fixup chain节点），而 dyld 则会利用这部分信息进行 rebase&amp;bind。<br>总体来说，Chained fixup方案中，dyld不需要再去一边读取LINKEDIT段信息一遍做rebase&amp;bind操作，而是直接沿着链表逐个读取节点，这样dyld即可在一次遍历中完成rebase及bind操作，减少了不必要的page压缩及解压缩操作，利用了空间局限性，减少了耗时。</p>\n<h4 id=\"Page-in-Linking\"><a href=\"#Page-in-Linking\" class=\"headerlink\" title=\"Page-in Linking\"></a>Page-in Linking</h4><p>今年的WWDC，苹果又公布了dyld的一项新功能，Page-in Linking。和过去 dyld 在启动时一次性统一修正所有的动态链接库符号不同，dyld现在可以在 page-in 的时候去自动修正 DATA 段内的 page。一直以来，内核都可以通过 mmap() 来访问 page，但是现在，如果它是一个 DATA page，内核在访问的同时还会顺便对其进行 fixup，这种机制减少了脏内存和启动时间，这也意味着 DATA_CONST 段的page是干净的，它们可以像 TEXT 页面一样被暂时移出内存和重新创建，从而减少内存压力。但 page-in linking 只适用于用 chained fixups 构建的二进制文件。这是因为在 chained fixups 中，大部分修复信息将被编码在磁盘上的 DATA 段中，这意味着在 page-in 时内核可以使用这些信息。<br>有一点需要注意的是，dyld 只会在应用启动时使用这一机制。任何后来被 dlopen() 打开的 dylibs 都不会进行 page-in linking。在这种情况下，dyld 会采用传统的方法，在调用 dlopen 时应用 fixup。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-12.png\" alt=\"dyld\"></p>\n<h2 id=\"动态链接在APP中的应用\"><a href=\"#动态链接在APP中的应用\" class=\"headerlink\" title=\"动态链接在APP中的应用\"></a>动态链接在APP中的应用</h2><p>iOS系统层面实际上运用了大量的动态链接库，可以在App的Mach-O文件的Load Commands中查看所有LC_LOAD_DYLIB动态库。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-13.png\" alt=\"dyld\"><br>但是对于APP来说，只能引入App内签名的动态库和系统签名的动态库，并不能如愿的引入第三方发布的动态链接库，原因在于dyld内部禁止加载非App签名的image文件，尝试加载会触发crashIfInvalidCodeSignature的crash。</p>\n<blockquote>\n<p><a href=\"https://opensource.apple.com/source/dyld/dyld-239.3/src/ImageLoaderMachO.cpp\">https://opensource.apple.com/source/dyld/dyld-239.3/src/ImageLoaderMachO.cpp</a><br><a href=\"https://opensource.apple.com/source/xnu/xnu-2422.1.72/osfmk/vm/vm_fault.c\">https://opensource.apple.com/source/xnu/xnu-2422.1.72/osfmk/vm/vm_fault.c</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ImageLoaderMachO::crashIfInvalidCodeSignature()​</span><br><span class=\"line\">&#123;​</span><br><span class=\"line\">        &#x2F;&#x2F; Now that segments are mapped in, try reading from first executable segment.​</span><br><span class=\"line\">        &#x2F;&#x2F; If code signing is enabled the kernel will validate the code signature​</span><br><span class=\"line\">        &#x2F;&#x2F; when paging in, and kill the process if invalid.​</span><br><span class=\"line\">        for(unsigned int i&#x3D;0; i &lt; fSegmentsCount; ++i) &#123;​</span><br><span class=\"line\">                if ( (segFileOffset(i) &#x3D;&#x3D; 0) &amp;&amp; (segFileSize(i) !&#x3D; 0) ) &#123;​</span><br><span class=\"line\">                        &#x2F;&#x2F; return read value to ensure compiler does not optimize away load​</span><br><span class=\"line\">                        int* p &#x3D; (int*)segActualLoadAddress(i);​</span><br><span class=\"line\">                        return \\*p;​</span><br><span class=\"line\">                &#125;​</span><br><span class=\"line\">        &#125;​</span><br><span class=\"line\">        return 0;​</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>即使在代码层面想办法绕过这个crash，在提审阶段，也会因为动态库签名问题遭到拒审。</p>\n<p><strong>应该如何引入动态库？</strong><br>苹果提供Embed这种方式来让项目引入动态库，其含义是不链接进项目的可执行文件，但是会被打包进ipa包，这样实际丧失了动态链接本身的空间优化和动态更新的优点。<br><img src=\"/2023/02/16/%E8%81%8A%E8%81%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/dyld-14.png\" alt=\"dyld\"><br>但动态链接真的就没有作用了吗？并不是这样。<br>随着大型程序的发展，需要链接的库会越来越多，业务研发同学可能会只专注于几个库的开发，此时将会面临代码修改后，编译链接时长增长、lldb调试卡顿等一系列问题，降低研发效能。<br>而将业务库作为动态链接库进行开发，编译时不再需要每次都重新构建一整个庞大的主二进制文件，而只需要重新构建各自业务对应的小动态库，研发复杂度大大降低，链接、调试和传输慢等一些列问题也就“迎刃而解”了。<br>但是增加动态库也会带来诸多其他问题，比如增加启动耗时。<br>业界普遍采用动态库懒加载方案，在程序启动时候默认不加载这些动态库，在启动结束后通过子线程预加载或者进入对应业务场景时候再按需加载对应的动态库。<br>总之，动态库的使用需要进行斟酌和取舍，研发效率和使用体验总需要进行平衡，没有银弹。</p>\n<h2 id=\"动态链接在Hook中的应用\"><a href=\"#动态链接在Hook中的应用\" class=\"headerlink\" title=\"动态链接在Hook中的应用\"></a>动态链接在Hook中的应用</h2><p>接触过Objc开发的同学对fishhook应该都不陌生，Method swizzle只能针对oc方法生效，对于c方法调用，需要使用fishhook，且fishhook只能针对跨模块方法Hook，为什么这样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * A structure representing a particular intended rebinding from a symbol</span><br><span class=\"line\"> * name to its replacement</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">struct fbr_rebinding &#123;</span><br><span class=\"line\">  const char *name;    &#x2F;&#x2F; 需要hook的方法名称</span><br><span class=\"line\">  void *replacement;   &#x2F;&#x2F; 替换方法的地址</span><br><span class=\"line\">  void **replaced;     &#x2F;&#x2F; 原始方法的地址</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> * For each rebinding in rebindings, rebinds references to external, indirect</span><br><span class=\"line\"> * symbols with the specified name to instead point at replacement for each</span><br><span class=\"line\"> * image in the calling process as well as for all future images that are loaded</span><br><span class=\"line\"> * by the process. If rebind_functions is called more than once, the symbols to</span><br><span class=\"line\"> * rebind are added to the existing list of rebindings, and if a given symbol</span><br><span class=\"line\"> * is rebound more than once, the later rebinding will take precedence.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">FISHHOOK_VISIBILITY</span><br><span class=\"line\">int fbr_rebind_symbols(struct fbr_rebinding rebindings[], size_t rebindings_nel);</span><br></pre></td></tr></table></figure>\n<p>fishhook实际上就是对动态链接的符号进行hook，之前我们说过，模块间的方法调用需要通过间接跳转，相关跳转方法最终存在DATA段的__got和__la_symbol_ptr中，通过修改这一部分即可达到Hook效果，而模块内的方法调用是固定在TEXT段中的，因此无法进行修改，这也就解释了为什么fishhook只能针对跨模块方法进行Hook。</p>\n<h2 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>动态链接的优点和缺点</li>\n<li>地址无关代码、延迟绑定的含义</li>\n<li>Mach-O动态链接过程</li>\n<li>iOS开发中使用动态链接库的意义</li>\n<li>Fishhook原理</li>\n</ul>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p>《程序员的自我修养——链接、装载与库》<br>Link fast: Improve build and launch times<br>Frameworks: embed or not embed that’s the question<br>Dynamic Library Programming Topics<br>iOS15 动态链接 fixup chain 原理详解</p>\n"}],"PostAsset":[{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/isa_t.png","slug":"isa_t.png","post":"ckwm7vn0v000027mjbhlzg4zl","modified":0,"renderable":0},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/class.png","slug":"class.png","post":"ckwm7vn0v000027mjbhlzg4zl","modified":0,"renderable":0},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/ro.png","slug":"ro.png","post":"ckwm7vn0v000027mjbhlzg4zl","modified":0,"renderable":0},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/rw.png","slug":"rw.png","post":"ckwm7vn0v000027mjbhlzg4zl","modified":0,"renderable":0},{"_id":"source/_posts/基于objc4的Runtime原理解读（一）/summary.png","slug":"summary.png","post":"ckwm7vn0v000027mjbhlzg4zl","modified":0,"renderable":0},{"_id":"source/_posts/基于objc4的Runtime原理解读（二）/class.png","slug":"class.png","post":"ckwunoxbf00020bmjhcgaapk0","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-1.png","slug":"dyld-1.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-10.png","slug":"dyld-10.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-11.png","slug":"dyld-11.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-12.png","slug":"dyld-12.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-13.png","slug":"dyld-13.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-2.png","slug":"dyld-2.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-3.png","slug":"dyld-3.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-4.png","slug":"dyld-4.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-5.png","slug":"dyld-5.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-6.png","slug":"dyld-6.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-7.png","slug":"dyld-7.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-8.png","slug":"dyld-8.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-9.png","slug":"dyld-9.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/mach-o.png","slug":"mach-o.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/static_linker_1.png","slug":"static_linker_1.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/static_linker_2.png","slug":"static_linker_2.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/static_linker_3.png","slug":"static_linker_3.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0},{"_id":"source/_posts/聊聊动态链接/dyld-14.png","slug":"dyld-14.png","post":"clecf0tyv0000gylg29yt32e7","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckw56w0wh0000j8t80sob8nzw","category_id":"ckwunoxbd00000bmjdueq4nij","_id":"ckwunoxbh00050bmj5uzzdsn0"},{"post_id":"ckwm7vn0v000027mjbhlzg4zl","category_id":"ckwunoxbg00030bmjb84hbuje","_id":"ckwunoxbi00090bmjfplg6qsx"},{"post_id":"ckwunoxbf00020bmjhcgaapk0","category_id":"ckwunoxbg00030bmjb84hbuje","_id":"ckww8jn9k0002cumjc9bjglqm"},{"post_id":"ckx64y36y0000d2mjc63h51r3","category_id":"ckwunoxbd00000bmjdueq4nij","_id":"ckx79weiq00018zmj9rp6dkff"},{"post_id":"clecf0tyv0000gylg29yt32e7","category_id":"ckwunoxbg00030bmjb84hbuje","_id":"clecf0tyw0003gylghio90wro"}],"PostTag":[{"post_id":"ckw56w0wh0000j8t80sob8nzw","tag_id":"ckw56w0wn0001j8t8drkghc60","_id":"ckw56w0wp0002j8t87grzhlug"},{"post_id":"ckwm7vn0v000027mjbhlzg4zl","tag_id":"ckwnmuim80000mqmjam4tcwd8","_id":"ckwnmuimc0001mqmj7nm72nyv"},{"post_id":"ckw56w0wh0000j8t80sob8nzw","tag_id":"ckwunoxbf00010bmjcpttafqw","_id":"ckwunoxbi00070bmj9bp2d4wk"},{"post_id":"ckw56w0wh0000j8t80sob8nzw","tag_id":"ckwunoxbh00040bmj8jxwbu77","_id":"ckwunoxbi00080bmjewtwgtsq"},{"post_id":"ckwm7vn0v000027mjbhlzg4zl","tag_id":"ckwunoxbh00060bmj0253d5wy","_id":"ckwunoxbi000b0bmj3rd7en30"},{"post_id":"ckwm7vn0v000027mjbhlzg4zl","tag_id":"ckwunoxbi000a0bmjbaoc05yy","_id":"ckwunoxbi000c0bmjd3sgcv6g"},{"post_id":"ckwunoxbf00020bmjhcgaapk0","tag_id":"ckwunoxbi000a0bmjbaoc05yy","_id":"ckww8jn9j0000cumj2hw66uqp"},{"post_id":"ckwunoxbf00020bmjhcgaapk0","tag_id":"ckwunoxbh00060bmj0253d5wy","_id":"ckww8jn9k0001cumjah7tf4z6"},{"post_id":"ckwunoxbf00020bmjhcgaapk0","tag_id":"ckwnmuim80000mqmjam4tcwd8","_id":"ckww8jn9k0003cumj223f3n6p"},{"post_id":"ckx64y36y0000d2mjc63h51r3","tag_id":"ckw56w0wn0001j8t8drkghc60","_id":"ckx64y3720001d2mjg1wlck6l"},{"post_id":"ckx64y36y0000d2mjc63h51r3","tag_id":"ckx64zi580001gimjbuzk1l3s","_id":"ckx79weip00008zmj8t7vaira"},{"post_id":"clecf0tyv0000gylg29yt32e7","tag_id":"clecalta300019ilg1xwt5mwy","_id":"clecf0tyw0001gylgdwzue3bn"},{"post_id":"clecf0tyv0000gylg29yt32e7","tag_id":"ckwnmuim80000mqmjam4tcwd8","_id":"clecf0tyw0002gylgefk80c5g"}],"Tag":[{"name":"none","_id":"ckf3jddlb0001xhnjhq3s0gus"},{"name":"Linux","_id":"ckw56w0wn0001j8t8drkghc60"},{"name":"iOS","_id":"ckwnmuim80000mqmjam4tcwd8"},{"name":"CLion","_id":"ckwunoxbf00010bmjcpttafqw"},{"name":"WSL","_id":"ckwunoxbh00040bmj8jxwbu77"},{"name":"objective-c","_id":"ckwunoxbh00060bmj0253d5wy"},{"name":"runtime","_id":"ckwunoxbi000a0bmjbaoc05yy"},{"name":"终端","_id":"ckx64zi580001gimjbuzk1l3s"},{"name":"linker","_id":"clecalta300019ilg1xwt5mwy"}]}}